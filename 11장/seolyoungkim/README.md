# Introduction
- DDL(Data Definition Language) : 데이터베이스나 테이블의 구조를 변경하기 위한 문장 
- DML(Data Manipulation Language) : 데이터를 조작(읽기/쓰기)하기 위한 문장

# 11.1 쿼리 작성과 연관된 시스템 변수 
## 11.1.1 SQL 모드 
- `sql_mode` 시스템 변수 : MySQL이 SQL을 처리하는 방법을 제어하는 데 사용
  - SQL 작성과 결과에 영향을 미침  
  - 가능한 변경하지 않는 것이 좋음
- 기본값 
  - `ONLY_FULL_GROUP_BY` 
    - GROUP BY 절에 명시되지 않은 컬럼을 SELECT 절이나 HAVING 절에서 사용할 수 없도록 함 
      - 적용하지 않으면 사용할 수 있음 
  - `STRICT_TRANS_TABLES`
    - InnoDB와 같이 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용  
    - Insert, Update, Delete 시에 잘못된 데이터가 발생하면 오류가 발생함 (select는 경고 발생)
      - 적용하지 않으면 경고만 발생 
  - `NO_ZERO_IN_DATE` & `NO_ZERO_DATE`
    - DATE 또는 DATETIME 컬럼에 잘못된 날짜를 저장하는 것을 불가능하게 함 
  - `ERROR_FOR_DIVISION_BY_ZERO`
  - `NO_ENGINE_SUBSTITUTION`


## 11.1.2 영문 대소문자 구분 
- OS에 따라 테이블명의 대소문자를 구분함 
  - Windows : 대소문자 구분하지 않음 
  - Unix 계열 OS : 대소문자 구분함
- `lower_case_table_names`: 이를 1로 설정하면 모두 소문자로만 저장되며, 대소문자를 구분하지 않게 해줌 
  - default는 0임 
- 가능한 경우 대문자 또는 소문자로만 통일해서 사용하자 

## 11.1.3 MySQL 예약어 
- https://dev.mysql.com/doc/refman/8.0/en/keywords.html 참고 
- 테이블을 생성할 때 예약어를 사용하면 오류가 발생함 
  - `로 테이블명을 감싸면 예약어를 사용할 수 있으나, 이렇게 하진 말자 

---

---

# 11.2 매뉴얼의 SQL 문법 표기를 읽는 법 
- `[]`: 해당 키워드나 표현식 자체가 선택 사항임 
- `|` : 앞과 뒤의 키워드나 표현식 중에서 단 하나만 선택해서 사용할 수 있음 
- `{}` : 괄호 내의 아이템 중에서 반드시 하나를 사용해야 함 
- `...` : 표현식이나 키워드를 반복해서 사용할 수 있음

---

---

# 11.3 MySQL 연산자와 내장 함수 
- 될 수 있으면 ANSI 표준을 따르는 것이 좋음

## 11.3.1 리터럴 표기법 문자열 
### 문자열 
- 작은 따옴표(`'`)로 감싸서 표현
  - MySQL은 `"` 사용 가능
- `''`는 문자열 내에서 작은 따옴표를 표현할 때 사용

### 숫자 
- 작은 따옴표(`'`)로 감싸지 않고 숫자 값을 입력 
- 주의할 점 
  - 숫자와 문자열은 서로 자동으로 타입 변환이 발생함 
  - MySQL은 숫자 타입을 우선시함
  - 예시 
    - number_col = '100' → 문자열 '100'을 숫자로 변환해서 비교
    - string_col = 100 → string_col의 값을 숫자로 변환해서 비교 → 인덱스 못탐 (or 비교가 실패 할수도 있음)
- 타입 변환이 발생하지 않도록 주의하자 

### 날짜 
- 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환함 
  - `'2023-11-23'` → DATE로 변환 

### 불리언 
- `BOOL`, `BOOLEAN`은 사실 `TINYINT` 타입에 대한 동의어일 뿐이다 (0 또는 1)
  - `TRUE`, `FALSE`와 비교하거나 값을 저장할 수 있다. 
    - `TRUE` → 1
    - `FALSE` → 0


## 11.3.2 MySQL 연산자 
### 동등 비교 
- `=` : 두 값이 동일한지 비교할 때 사용
  - `NULL`과 `NULL`, `NULL`과 다른 값을 비교하면 `NULL`을 반환함  
  - `NULL`과 비교할 때는 `IS NULL`을 사용해야 함
- `<=>` : NULL을 포함한 두 값이 동일한지 비교할 때 사용
  - MySQL에서 제공하는 연산자 

### 부정 비교 
- `<>` 또는 `!=` 사용 

### NOT 연산자
- `NOT` : TRUE, FALSE 연산의 결과를 반대로 만드는 연산자 
  - `NOT (a = b)`와 `(a <> b)`는 동일함

### AND, OR 연산자
- `AND`, `OR` : 논리 연산자 
  - `AND`는 `OR`보다 우선순위가 높음 
  - `AND`와 `OR`를 같이 사용할 때는 괄호를 사용해서 우선순위를 명확하게 해주는 것이 좋음

### 나누기(`/`, `DIV`)와 나머지(`%`, `MOD`) 연산자 
- `/` : 나누기 연산자 
- `DIV` : 몫을 구하는 연산자
- `%` or `MOD` : 나머지 연산자

### REGEXP 연산자
- `REGEXP` : 정규 표현식을 사용해서 문자열을 비교할 때 사용 
  - `LIKE`와 달리 정규 표현식을 사용할 수 있음 
  - `RLIKE`는 `REGEXP`와 동일함
- 인덱스 레인지 스캔 사용 불가 

### LIKE 연산자
- 어떤 상수 문자열의 유무를 판단하는 연산자 
- `%` : 0 or 1개 이상의 모든 문자에 일치 (문자 내용 관계 x)
- `_` : 정확히 1개의 문자에 일치 (문자 내용 관계 x)
- `a%` or `a_` : 인덱스 레인지 스캔 사용 가능. 인덱스는 앞쪽을 비교하기 때문에, 앞이 고정되어 있어야 함 
  - `%a` or `_a` : 인덱스 레인지 스캔 사용 불가

### BETWEEN 연산자
- `BETWEEN` : 두 값 사이에 있는지 확인하는 연산자 
  - `a BETWEEN b AND c` : `a >= b AND a <= c`와 동일함
  - `NOT BETWEEN` : `BETWEEN`의 반대
- 인덱스 사용시 주의점 
  ```mysql
  -- pk = (dept_no, emp_no)
  SELECT * FROM dept_emp WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;
  ```
  - 위 쿼리는 d003부터 d005까지 모두 조회한다. `emp_no`는 비교 범위를 줄이는 역할을 하지 못한다. 
    - 실제 조회되는 데이터가 1건이라고 해도, d003~d005까지의 모든 데이터를 스캔한다.
  - 위 쿼리는 아래와 같이 개선할 수 있다.
    ```mysql
    SELECT * FROM dept_emp WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no = 10001;
    ```
    - 동등 비교를 수행함으로써 모든 범위를 스캔하지 않게 만든다. 
  - 인덱스 앞쪽에 있는 컬럼의 선택도가 떨어질 때는 IN으로 변경하는 것이 성능을 개선할 수도 있음.
  - ![img.png](img.png)


### IN 연산자
- `IN` : 여러 개의 값에 대해 동등 비교 연산을 수행 
  - 여러 번의 동등 비교로 실행 → 일반적으로 빠르게 처리 
- `IN (?, ?, ?)` : 상수가 사용된 경우
- `IN (SELECT ...)` : 서브쿼리가 사용된 경우
- `NOT IN` : 부정형 비교이기 때문에 인덱스 풀 스캔을 하는 경우가 많음


## 11.3.3 MySQL 내장 함수
### NULL 값 비교 및 대체 
- `IFNULL(expr1, expr2)`
  - expr1: NULL인지 아닌지 비교하려는 컬럼 혹은 표현식. NULL이 아닐 경우 expr1을 반환함
  - expr2: expr1이 NULL인 경우 대체할 값이나 컬럼. NULL이 아닐 경우 expr2를 반환함 
- `ISNULL(expr)` : expr이 NULL이면 1을 반환하고, 그렇지 않으면 0을 반환


### 현재 시각 조회 
- `NOW()` : 현재 시각을 반환함
  - 하나의 SQL 문장 내의 NOW() 함수는 모두 같은 값을 가짐 
- `SYSDATE()` : 현재 시각을 반환함
  - 하나의 SQL 문장 내에서도 호출 시점에 따라 결괏값이 달라짐 
  - 레플리카 서버에서 안정적으로 복제되지 못함 
  - 인덱스를 효율적으로 사용하지 못함 
    - 호출 시점에 따라 값이 달라지기 때문에, 상수가 아님. 인덱스 스캔 시에도 매번 비교되는 레코드마다 함수가 실행돼야 함.
  - 그러니 왠만하면 사용 ㄴㄴ


### 날짜와 시간 포맷 
- `DATE_FORMAT(date, format)` : 날짜를 원하는 포맷으로 변환함
  - date: 날짜 값
  - format: 날짜 포맷 (ex: `%Y-%m-%d`)
- `STR_TO_DATE(str, format)` : 문자열을 날짜로 변환함
  - str: 날짜 형식의 문자열
  - format: 날짜 포맷


### 날짜와 시간 연산 
- `DATE_ADD(date, INTERVAL expr unit)` : 날짜에 일정 기간을 더함
  - date: 날짜 값
  - expr: 더하고자 하는 기간
  - unit: 기간의 단위 (ex: DAY, MONTH, YEAR)
- `DATE_SUB(date, INTERVAL expr unit)` : 날짜에 일정 기간을 뺌
  - date: 날짜 값
  - expr: 빼고자 하는 기간
  - unit: 기간의 단위 (ex: DAY, MONTH, YEAR)


### 타임스탬프 연산
- `UNIX_TIMESTAMP()` : 현재 시각을 타임스탬프로 반환함
  - `1970-01-01 00:00:00`부터 현재 시각까지의 경과된 초를 반환
  - 4바이트 숫자 타입이기 때문에 `1970-01-01 00:00:00` ~ `2038-01-19 03:14:07`까지만 표현 가능
- `FROM_UNIXTIME(unix_timestamp)` : 타임스탬프를 날짜로 변환함


### 문자열 결합 
- `CONCAT(str1, str2, ...)` : 여러 개의 문자열을 결합함
  - str1, str2, ...: 결합할 문자열


### 값의 비교 및 대체 
- `CASE WHEN ... THEN ... END`
  - `SWITCH` 구문과 같은 역할을 함 


---

---

# 11.4 SELECT
## 11.4.1 SELECT 절의 처리 순서 
```mysql
SELECT s.emp_no, COUNT(DISTINCT e. first_name) AS cnt  -- SELECT 절
FROM salaries s  -- FROM 절
INNER JOIN employees e ON e.emp_no=s. emp_no
WHERE s.emp_no IN (100001, 100002)  -- WHERE 절
GROUP BY s.emp_no  -- GROUP BY 절
HAVING AVG(s.salary) > 1000  -- HAVING 절
ORDER BY AVG(s.salary)  -- ORDER BY 절
LIMIT 10;  -- LIMIT 절
```
- 각 쿼리 절의 실행 순서 
  - ![img_1.png](img_1.png)
  - 인덱스를 이용해 처리할 때는 GROUP BY, ORDER BY 자체가 불필요하므로 생략됨 
- GROUP BY 절이 없이 ORDER BY 절만 사용된 쿼리에서는 아래와 같이 실행 순서가 적용될 수 있음 
  - ![img_2.png](img_2.png)

## 11.4.2 WHERE 절, GROUP BY 절, ORDER BY 절의 인덱스 사용 
### 인덱스를 사용하기 위한 기본 규칙 
- 인덱스된 컬럼 값 자체를 변환하지 않고 그대로 사용해야 함 
- WHERE 절의 비교 조건에서, 두 비교 대상 값은 데이터 타입이 일치해야 함  
  - 저장이든 비교든 타입은 일치시키자. 

### WHERE 절의 인덱스 사용 
- 동등 비교 or IN 으로 구성된 조건에 사용된 컬럼들이 인덱스의 컬럼 구성과 좌측에서 비교했을 때 얼마나 일치하는가에 따라 달라짐
- ![img_3.png](img_3.png)
  - 위 예제는 AND 조건에 대한 예제이다. 
  - 인덱스 순서와 WHERE 조건절의 순서는 실제 인덱스 사용 여부와 무관함 
  - COL3이 범위 비교 조건으로 사용됐기 때문에, COL4는 체크 조건으로 사용된다. 
    - 결국, 인덱스 컬럼 순서와 비교 조건이 중요하지, WHERE 조건절의 순서는 중요하지 않다.
 
- WHERE절에 OR가 있으면 주의해야 함 
  - AND로 연결되면 읽어와야 할 레코드 건수를 줄이는 역할을 하지만,
  - OR로 연결되면 읽어서 비교해야 할 레코드가 더 늘어나기 때문 

### GROUP BY 절의 인덱스 사용
- GROUP BY 절에 명시된 컬럼의 순서가 인덱스를 구성하는 컬럼의 순서와 같으면 인덱스를 사용할 수 있음
- 인덱스를 구성하는 컬럼 중, 뒤쪽에 있는 컬럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있음
  - 즉, 다중 컬럼 인덱스 중에서 일부만 명시되어도 되지만, 뒤쪽의 인덱스만 제외될 수 있음   
  - 따라서, 인덱스의 앞쪽에 있는 컬럼은 명시되지 않으면 인덱스를 사용할 수 없음
- GROUP BY 절에 명시된 컬럼이 하나라도 인덱스에 없으면 전혀 인덱스를 이용할 수 없음
- 예제 
  - ex1: 인덱스가 (a, b, c)일 때, GROUP BY a, b, c, d, e, f는 인덱스를 사용할 수 없음
  - ex2: 인덱스가 (a, b, c)일 때, GROUP BY b, c는 인덱스를 사용할 수 없음
  - ex3: 인덱스가 (a, b, c)일 때, GROUP BY a, c는 인덱스를 사용할 수 없음
  - ex4: 인덱스가 (a, b, c)일 때, GROUP BY a는 인덱스를 사용할 수 있음
  - ex5: 인덱스가 (a, b, c)일 때, GROUP BY a, b는 인덱스를 사용할 수 있음
  - ex6: 인덱스가 (a, b, c)일 때, GROUP BY a, b, c는 인덱스를 사용할 수 있음

### ORDER BY 절의 인덱스 사용
- GROUP BY와 상당히 흡사함 
- 정렬되는 각 컬럼의 ASC, DESC 옵션이 인덱스와 같거나 정반대인 경우에만 사용 가능 

### WHERE 절과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용
- WHERE, ORDER(GROUP) BY가 함께 사용된 경우 다음 중 한가지 방법으로만 인덱스를 이용함 
  - WHERE 절과 ORDER BY 절이 동시에 같은 인덱스 이용 (가장 빠름)
    - WHERE 절과 ORDER BY 절에 사용된 인덱스의 순서는 선언된 인덱스 순서와 일치해야 함
      - ![img_4.png](img_4.png)
  - WHERE 절만 인덱스를 이용 
    - ORDER BY 절은 인덱스를 이용한 정렬이 불가능 
    - Filesort를 사용해서 정렬을 수행함
    - WHERE 절 조건에 일치하는 레코드 건 수가 많지 않을 때 효율적 
  - ORDER BY 절만 인덱스를 이용 
    - ORDER BY 절의 순서대로 인덱스를 읽으면서 한 건씩 WHERE 절 조건에 일치하는지 비교

### GROUP BY 절과 ORDER BY 절의 인덱스 사용
- GROUP BY 절과 ORDER BY 절에 명시된 컬럼 순서와 내용이 모두 같아야 함 
- 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 모두 인덱스 사용 불가 

### WHERE 조건과 GROUP BY 절, ORDER BY 절의 인덱스 사용
- WHERE 절과 GROUP BY 절, ORDER BY 절이 모두 포함된 쿼리가 인덱스를 사용하는 지 판단하는 방법 
  - ![img_5.png](img_5.png)
    1. WHERE 절이 인덱스를 사용할 수 있는가?
    2. GROUP BY 절이 인덱스를 사용할 수 있는가?
    3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?


## 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항 
### NULL 비교
- MySQL은 NULL이 포함된 레코드도 인덱스로 관리됨 
  - NULL을 하나의 값으로 인정하여 관리함 
  - SQL 표준에서 NULL은 값이 없음을 의미하며, 비교할 수 없음  
- `IS NULL` 연산자를 사용해서 비교

### 문자열이나 숫자 비교 
- 문자열이나 숫자를 비교할 때는 반드시 그 타입에 맞는 상숫값을 사용할 것 
- 다른 타입을 사용할 경우 인덱스를 이용하지 못할 수 있음 

### 날짜 비교 
- `DATE`, `DATETIME`과 문자열 비교 
  - 문자열 값을 자동으로 DATETIME으로 변환해서 비교를 수행 
  - MySQL이 내부적으로 변환을 수행함 
  - `hire_date > STR_TO_DATE('2000-01-01', '%Y-%m-%d')`, `hire_date > '2000-01-01'` 둘 모두 성능상 문제 X
  - `DATE_FORMAT(hire_date, '%Y-%m-%d') > '2000-01-01'`은 성능상 문제 발생 가능 
    - `hire_date` 컬럼을 변경함 → 인덱스 못탐
    - 컬럼을 타입 변환하지 말고, 비교할 상수 값을 변환하도록 하는게 좋음
  - 컬럼의 변형은 인덱스를 타지 못하게 하는 원인이다 

- `DATE`와 `DATETIME`의 비교 
  - 그냥 비교하면 MySQL 서버가 DATE를 DATETIME으로 변환해서 비교함
  - 인덱스 사용 여부에 영향 X
  - 성능보다는 쿼리의 결과에 주의해서 사용할 것 

- `DATE`와 `TIMESTAMP`의 비교
  - 서로 비교 불가 
  - `TIMESTAMP`를 `DATETIME`으로 변환해서 비교해야 함

### Short-circuit evaluation
- `AND` 또는 `OR` 연산자로 연결된 조건식에서, 앞의 조건식의 결과에 따라 뒤의 조건식을 평가하지 않는 것 
  - `AND` 연산자로 연결된 조건식에서, 앞의 조건식이 FALSE이면 뒤의 조건식을 평가하지 않음 
  - `OR` 연산자로 연결된 조건식에서, 앞의 조건식이 TRUE이면 뒤의 조건식을 평가하지 않음
- 하지만 Where 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있는 경우, `Short-circuit evaluation`과는 무관하게 해당 조건을 가장 최우선으로 사용함
  - 나열 순서대로 평가하는게 아니라, 인덱스를 사용할 수 있는 조건을 우선적으로 평가함
  - 인덱스를 사용하지 못하는 조건은 순서대로 평가하므로, 위치 조절을 잘 하자 (복잡한건 뒤로 보내셈)

## 11.4.4 DISTINCT
- 남용하면 성능적인 문제 뿐만 아니라, 쿼리 결과도 의도한 바와 다를 수 있음 
- 1:1 조인인지, 1:N 조인인지 업무적인 특성을 잘 이해하는 것이 중요 

## 11.4.5 LIMIT n
- 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용 
- MySQL에서 해당 문장은 항상 쿼리의 가장 마지막에 실행됨 
- LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리 종료 
  - 정렬, 그루핑, DISTINCT가 없는 경우 쿼리가 상당이 빨리 끝나게 하는 효과를 가져올 수 있음 
  - GROUP BY는 처리가 완료되고 나서야 LIMIT 처리 수행 가능
  - DISTINCT를 위한 중복 제거 작업을 반복적으로 처리하다가 LIMIT 건수만큼 채워지면 쿼리를 멈춤 
  - 정렬을 수행하면서 필요한 LIMIT 건수를 완성하는 순간 쿼리를 종료함
- 인덱스를 탈 수 있으면 LIMIT은 쿼리 작업량을 상당히 줄여주는 효과가 있음 
- 실제 쿼리의 성능은 출력되는 건 수 보다, MySQL 서버가 어떠한 작업들을 했는지가 중요함
  - `LIMIT 20000, 10` 이렇게 쓰기 보다, Where 절로 레코드 건수를 줄인 후 `LIMIT 0, 10`과 같은 형태로 사용하자

## 11.4.6 COUNT()
- `COUNT(*)` : NULL을 포함한 모든 레코드 수를 반환함
- 큰 테이블에서 COUNT() 함수를 사용하는 작업은 주의하자 
- 대략적인 건수만 알아도 될 경우 `SHOW TABLE STATUS`를 사용하는 것이 좋음
- `ORDER BY`는 아무 필요도 없으므로 함께 쓰지 말자
- `COUNT(col1)`은 col1이 NULL인 레코드는 제외하고 카운트함

## 11.4.7 JOIN 
### JOIN 순서와 인덱스 
- 인덱스 레인지 스캔 = 인덱스 탐색 + 인덱스 스캔 
- 드라이빙 테이블은 인덱스 탐색 작업을 1회 수행하고, 그 이후부터는 스캔만 수행 
  - 드리븐 테이블은 인덱스 탐색과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복 
  - 즉, 부하 자체가 드리븐 테이블이 훨씬 큼 
    - 옵티마이저는 드리븐 테이블을 최적으로 읽을 수 있도록 실행 계획을 수립함 
- 드라이빙 테이블, 드리븐 테이블 모두 인덱스가 있는 경우가 가장 빠름 
- 한쪽만 인덱스가 있는 경우, 인덱스가 없는 쪽을 드라이빙 테이블로 선택함 
- 모두 인덱스가 없는 경우 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택함 (해시 조인)

### JOIN 컬럼의 데이터 타입 
- 조인 컬럼 간의 비교에서는 각 데이터 타입이 일치해야 인덱스를 효율적으로 이용할 수 있음 
  - 문제가 될 수 있는 타입 비교 패턴
    - 데이터 타입 종류가 완전히 다른 경우  
    - 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 다른 경우 
    - 같은 INT 타입이라도 Sign 존재 여부가 다른 경우 

### OUTER JOIN의 성능과 주의 사항 
- 이너 조인은 조인 대상 테이블에 모두 존재하는 레코드만 결과 집합으로 반환함 
- 아우터 조인은 조인 대상 테이블을 드라이빙 테이블로 선택하지 못함 
  - 이너 조인이 더 효율적으로 처리됨 
  - 그러니 이너 조인으로 사용해도 되는 쿼리는 아우터 조인으로 작성하지 말자 
- 아우터 조인에 WHERE 절 함께 명시 → 이너 조인으로 처리됨
  - 아우터 조인을 쓰고싶다면 이러지 말자 
  - 조건을 ON 절에 작성해라 
- 안티 조인 효과를 기대할 때는 Where를 써도 됨 

### JOIN과 FK 
- FK는 조인과 아무런 연관이 없음 
- FK는 데이터 무결성을 보장하기 위함 

### 지연된 조인 
- 조인 + GROUP BY / ORDER BY 를 사용할 때 
  - 인덱스를 사용하는 경우 최적으로 처리되고 있을 가능성이 높음 
  - 인덱스를 사용할 수 없는 경우, 조인을 모두 실행한 후 GROUP BY / ORDER BY를 수행함
    - 조인은 대체로 결과 레코드 건수가 늘어난다는 특징이 있음 
    - 조인 결과를 GROUP BY, ORDER BY를 하면 조인 전보다 더 많은 레코드를 처리해야 할 수 있음 
    - 지연된 조인이란, 조인 실행 전에 GROUP BY, ORDER BY를 수행하는 것을 의미함
    - 지연된 조인은 LIMIT이 함께 사용되면 더 큰 효과를 얻을 수 있음 

### 래터럴 조인 
- 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인

### 실행 계획으로 인한 정렬 흐트러짐 
- 네스티드 루프 조인은 드라이빙 테이블에서 읽은 레코드의 순서가 모두 조인돼도 그대로 유지됨
- 해시 조인이 사용되는 경우, 쿼리 결과와 레코드 정렬 순서가 달라짐 
  - 드라이빙 테이블을 읽는 순서와 정렬 순서가 다르게 출력됨  
  - 정렬된 결과가 필요한 경우, ORDER BY를 사용해서 정렬을 수행해야 함


## 11.4.8 GROUP BY 
### WITH ROLLUP
- 그루핑된 그룹별로 소계/총계를 가져오는 기능 

### 레코드를 컬럼으로 변환해서 조회 
- 하나의 레코드를 여러 개의 컬럼으로 나누거나 변환하는 SQL 문법은 없음 
- 집합 함수 + `CASE WHEN ... END` 구문을 이용해서 변환하는 것은 가능


## 11.4.9 ORDER BY
- ORDER BY 절이 없는 경우
  - 인덱스를 사용한 SELECT 쿼리는 인덱스의 정렬 순서대로 결과를 반환함
  - 풀 테이블 스캔 SELECT 쿼리는 InnoDB의 경우, 항상 PK로 클러스터링 되어있기 때문에 PK 순서대로 레코드를 가져옴 
  - SELECT 쿼리가 임시 테이블을 거쳐 처리되면, 조회되는 레코드 순서를 예측하기는 어려움 
  - ORDER BY 절이 없으면 어떠한 정렬도 보장되지 않으니, 정렬이 필요하다면 ORDER BY 절을 반드시 명시하자
- 인덱스를 사용하지 못하는 ORDER BY
  - 추가 정렬 작업 수행 
  - `Using filesort`

### 사용법 및 주의사항 
- 1개 또는 그 이상의 컬럼으로 정렬 수행 가능 
  - 정렬 순서는 컬럼 별로 다르게 명시 가능 

### 여러 방향으로 동시 정렬 
- `ORDER BY col1 ASC, col2 DESC`와 같이 여러 컬럼을 동시에 정렬할 수 있으며, MySQL 8.0 부터는 인덱스도 사용 가능 
  - 혼용해서 정렬할 경우, 옵션을 섞어서 인덱스를 만들면 됨 
    - `col1, col2 DESC`로 인덱스를 생성


## 11.4.10 서브쿼리 
- SELECT 절에 사용되는 서브쿼리는 반환 결과가 0건 or 1건이어야 한다 
- 조인으로 처리해도 되는 쿼리를 굳이 서브쿼리를 쓰지 말자 
  - 조인으로 처리할 떄가 좀 더 빠르다 
  - 가능하면 조인으로! 
- FROM 절에 사용되는 서브쿼리 
  - 외부 쿼리와 병합하는 최적화 수행 
  - 병합되지 못하는 경우 
    - 집합 함수
    - DISTINCT 
    - GROUP BY or HAVING
    - LIMIT
    - UNION
    - SELECT 절에 서브쿼리가 사용된 경우 
    - 사용자 변수를 사용하는 경우
- WHERE 절에 사용되는 서브쿼리
  - `= (subquery)` or 크다 작다 비교 
    - 서브쿼리를 먼저 상수로 변환 
  - `IN (subquery)`
    - 세미 조인의 한 형태 
    - 테이블 풀 아웃, 퍼스트 매치, 루스 스캔, 구체화, 중복 제거 등의 방법으로 처리  
  - `NOT IN (subquery)`
    - 안티 세미 조인 
    - Not-Equal은 인덱스를 제대로 활용할 수 없듯, 안티 세미 조인 또한 최적화 방법이 많지 않음
    - NOT EXISTS 또는 구체화 방법 사용 
    - 성능 향상에 도움이 안되니까 다른 조건을 활용해서 데이터 검색 범위를 좁힐 수 있게 하자 


## 11.4.11 CTE(Common Table Expression)
- 이름을 가지는 임시 테이블 
- SQL 문장 내에서 한 번 이상 사용 가능 & SQL 문장 종료 시 임시 테이블 삭제


## 11.4.12 윈도우 함수(Window Function)
- 조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행 
- GROUP BY → 그룹 별로 하나의 레코드로 묶어서 출력
- 윈도우 함수 → 조건에 일치하는 레코드 건수는 변하지 않고 그대로 유지
- 실행 순서
  - ![img_6.png](img_6.png)


## 11.4.13 잠금을 사용하는 SELECT 
- `FOR SHARE` : 읽기 잠금 
  - Shared Lock 사용 
  - 다른 세션에서 읽는 것은 가능하나, 변경하지 못하게 함 
- `FOR UPDATE` : 쓰기 잠금 
  - Exclusive Lock 사용
  - 레코드 변경 뿐만 아니라, FOR SHARE 를 사용하는 SELECT도 수행할 수 없음
    - Q. FOR SHARE 를 사용하지 않는 SELECT는 수행할 수 있나..?
      - A. 가능함. [공식문서 SELECT FOR UPDATE 참고](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)
      - InnoDB 스토리지 엔진을 사용하는 테이블에서는 잠금 없는 읽기를 지원
        - 특정 레코드가 잠겨진 상태라 하더라도, `FOR SHARE`나 `FOR UPDATE`를 사용하지 않는 SELECT 문장은 아무런 대기 없이 실행 가능 

### 잠금 테이블 선택 
- 여러 테이블을 조인해서 읽으면서 `FOR UPDATE`를 사용할 때 
  - 여러 테이블에서 읽은 레코드에 대해 모두 Exclusive Lock을 걸게 됨 
- 선택적으로 잠글 수 있는 옵션 제공
  - `FOR UPDATE OF {테이블 이름 | 테이블 별칭}`

### NOWAIT & SKIP LOCKED
- `NOWAIT` : 대기 없이 바로 에러를 반환함
- `SKIP LOCKED` : 잠금이 걸린 레코드는 건너뛰고 읽음
  - 잠긴 레코드는 무시하고, 잠금이 걸리지 않은 레코드만 가져옴 
  - 확정적이지 않은 쿼리가 됨 (NOT-DETERMINISTIC)
    - 확정적: 입력이 동일하면 시점에 관계 없이 동일한 결과를 반환함 
    - 비확정적: 입력이 동일해도 시점에 따라 결과가 달라질 수 있음
      - 비확정적 쿼리는 소스 서버와 레플리카 서버의 데이터를 다르게 만들 수도 있으니 복제의 바이너리 로그 포맷은 ROW나 MIXED를 사용하자 
- 해당 기능은 Queue와 같은 기능을 MySQL 서버에서 구현하고자 할 때 유용함 


---

---

# 11.5 INSERT 
- INSERT와 SELECT의 성능을 동시에 빠르게 만들 수 있는 테이블 구조는 없음 
  - 성능 타협 필요 

## 11.5.1 고급 옵션 
- 유니크 인덱스나 PK에 대해 중복 레코드를 어떻게 처리할 것인가? 

### INSERT IGNORE
- PK나 유니크 인덱스 컬럼의 값이 중복되는 경우, 그리고 저장하는 컬럼이 테이블의 컬럼과 호환되지 않는 경우 무시하고 다음 레코드를 처리 
  - 에러를 발생시키지 않고 경고만 함 
  - 데이터 타입이 일치하지 않는 경우에는 기본 값을 할당 해주기도 함 

### INSERT ... ON DUPLICATE KEY UPDATE
- PK나 유니크 인덱스 컬럼의 값이 중복되는 경우
  - 기존 레코드를 삭제하지 않고 중복된 레코드를 UPDATE
- 일별로 집계되는 값을 관리할 때 편리하게 사용 가능 


## 11.5.2 LOAD DATA 주의 사항
- 데이터를 빠르게 적재할 수 있는 방법 
  - MySQL 엔진, 스토리지 엔진의 호출 횟수 최소화 
  - 스토리지 엔진이 직접 데이터를 적재
  - INSERT에 비해 빠름 
- 단점
  - 단일 스레드로 실행됨 
    - 데이터 적재 시간이 길어질 경우 온라인 트랜잭션 쿼리들의 성능이 영향을 받을 수 있음
  - 단일 트랜잭션으로 실행됨 
    - 문장 시작 시점부터 언두 로그가 삭제되지 못하고 유지돼야 함 
    - 언두 로그를 디스크로 기록해야 하는 부하 증가 
    - 언두 로그가 많이 쌓일 경우, 레코드를 읽는 쿼리들이 필요한 레코드를 찾는 데 더 많은 오버헤드 
- 가능하다면...
  - 적재할 데이터 파일을 하나보다는 여러 개의 파일로 준비해서 여러 트랜잭션으로 나누어서 실행하자 
  - 테이블 간 데이터 복사 작업이라면 LOAD DATA 문장보다는 INSERT ... SELECT ... 문장으로 WHERE 조건 절에서 데이터를 부분적으로 잘라서 효율적으로 INSERT하는 것이 좋음
    - 여러 개의 스레드로 실행하기에 용이


## 11.5.3 성능을 위한 테이블 구조 
- INSERT는 쿼리 문장보다는 테이블 구조에 의해 성능이 결정됨 

### 대량 INSERT 성능 
- 하나의 INSERT 문장으로 수백 건, 수천 건의 레코드를 INSERT하는 경우
  - PK 값 기준으로 미리 정렬해서 INSERT 문장을 구성하는 것이 성능에 도움이 될 수 있음 
- PK 정렬 여부가 중요 
- 세컨더리 인덱스는 SELECT 성능을 높이나, INSERT 성능은 저하시킨다 
  - 테이블에 세컨더리 인덱스가 많을수록, 테이블 크기가 클수록 성능은 더 떨어짐 
  - 이 또한 정렬된 순서대로 INSERT될 수 있다면 빠른 성능 가능 
    - 보장하긴 어려움 
  - 테이블의 세컨더리 인덱스를 너무 남용하지는 말자 
    - 너무 많은 세컨더리 인덱스는 백그라운드 작업의 부하를 유발하여 전체적인 성능이 떨어질 수 있음 

### 프라이머리 키 선정
- PK 순서와 무관하게 랜덤하게 저장된다면 
  - MySQL 서버는 레코드를 INSERT할 때마다 저장될 위치를 찾아야함 
  - B-Tree 전체가 메모리에 올라와 있어야 빠른데, 테이블 크기가 클수록 메모리 용량에 한계가 오고, 결국 저장될 위치를 찾기 위해 디스크 읽기가 발생 
- INSERT 성능과 SELECT 성능, 이 두 가지 요소는 서로 대립된다 
  - 이 둘을 모두 만족하는 PK를 찾기는 어렵다 
- OLTP에서는 쓰기보다는 읽기 쿼리 비율이 압도적으로 높음 → 읽기 쿼리를 위한 PK 선정이 중요
  - 쿼리에 맞게 필요한 인덱스들을 추가해도 됨 
- 만약 INSERT가 매우 많이 실행된다면...
  - PK를 단조 증가/감소하는 패턴의 값을 선택하는 것이 좋음
  - 인덱스 개수를 최소화하는 것이 좋음

### AUTO_INCREMENT
- 자동 증가 값을 PK로 해서 테이블을 생성하는 것이 가장 빠른 INSERT를 보장하는 방법임 
  - 세컨더리 인덱스가 하나도 없다면 더 좋음 
- 자동 증가 값의 채번
  - 잠금이 필요함 → AUTO-INC Lock 사용 
  - 락 모드 
    - `innodb_autoinc_lock_mode = 0` : AUTO-INC Lock 을 걸고 한번에 1씩만 증가된 값을 가져옴 
    - `innodb_autoinc_lock_mode = 1` (Consecutive Mode)
      - 한 건씩 INSERT → AUTO-INC Lock 을 사용하지 않고, 뮤텍스를 이용해 더 가볍고 빠르게 처리
      - 여러 레코드 INSERT or LOAD DATA → AUTO-INC Lock 을 걸고 필요한 만큼의 자동 증가 값을 한꺼번에 가져와서 사용 
    - `innodb_autoinc_lock_mode = 2` (Interleaved Mode)
      - 벌크 INSERT or LOAD DATA에 AUTO-INC Lock을 걸지 않음
      - 자동 증가 값을 적당히 미리 할당받아 처리 가능 
      - 단조 증가하는 유니크한 번호까지만 보장함 
        - 연속성은 보장하지 않음 
      - 쿼리 기반의 복제를 사용하는 경우, 소스 서버와 레플리카 서버의 자동 증가 값이 동기화되지 못할 수 있으므로 주의 


# 11.6 UPDATE와 DELETE
### UPDATE ... ORDER BY ... LIMIT n
- 특정 컬럼으로 정렬해서 상위 몇 건만 변경 및 삭제하는 쿼리 
- 너무 많은 레코드를 한번에 변경/삭제하는 것은 서버에 과부하를 유발하거나 다른 커넥션의 쿼리 처리를 방해할 수 있음
  - 이럴 때 LIMIT으로 잘라서 처리 
- 복제 소스 서버에서 문제가 될 수 있음 (바이너리 로그 포맷이 STATEMENT인 경우 문제)
- 복제가 구축된 MySQL 서버에서 ORDER BY가 포함된 UPDATE/DELETE 사용 시 주의 

### JOIN UPDATE
- 두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭제하는 쿼리 
- 조인된 테이블 중 특정 테이블의 컬럼 값을 다른 테이블의 컬럼에 업데이트해야 할 때 주로 이용 
  - 또는 양 테이블에 공통으로 존재하는 레코드만 찾아서 업데이트 하는 용도 
- 읽기 참조만 되는 테이블은 읽기 잠금이 걸림 
  - 컬럼이 변경되는 테이블은 쓰기 잠금이 걸림 
  - OLTP에서는 데드락 유발 가능성이 높음 → 빈번한 사용 피할 것 
  - 배치 프로그램이나 통계용으로는 유용하게 사용 가능 
- GROUP BY, ORDER BY는 사용 불가 
  - 서브 쿼리를 이용한 파생 테이블을 사용해야 함 

### 여러 레코드 UPDATE
- 하나의 UPDATE 문장으로 여러 레코드를 업데이트 하는 경우, 모든 레코드를 동일한 값으로만 업데이트 가능
- Row Constructor 문법
  - `VALUES ROW(...), ROW(...), ...` 
  - SQL 문장 내에서 임시 테이블을 생성하는 효과 

### JOIN DELETE
- `DELETE {테이블명1}, {테이블명2}... FROM {테이블1}, {테이블2}... WHERE ...`

---

---

# 11.7 스키마 조작(DDL)
- DDL(Data Definition Language) : dbms 서버의 모든 오브젝트를 생성하거나 변경하는 쿼리  

## 11.7.1 온라인 DDL
- 온라인 DDL : 테이블을 사용하는 동안에도 테이블의 스키마를 변경할 수 있는 기능

### 알고리즘 
- 온라인 DDL
  - 스키마를 변경하는 작업 도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경하거나 조회하는 작업을 가능하게 해줌 
  - 테이블 구조 변경, 인덱스 추가와 같은 대부분의 작업에 대해 작동함
- ALGORITHM 
  - `INSTANT`
    - 테이블 데이터 변경 X
    - 메타 데이터만 변경하고 작업을 완료함 → 메타 데이터만 잠그므로 LOCK이 필요 없음 
    - 레코드 건수와 무관하게 작업 시간이 매우 짧음
    - 스키마 변경 도중 R/W는 대기하게 되지만, 변경 시간이 매우 짧기 때문에 다른 커넥션의 쿼리 처리에는 크게 영향 X
  - `INPLACE` → 테이블 데이터를 변경할 때 사용 
    - 임시 테이블로 데이터를 복사하지 않고 스키마 변경 실행 
    - 내부적으로 테이블 리빌드를 실행 할수도 있음 
      - 테이블 크기에 따라 많은 시간이 소요될 수 있음
      - PK를 추가하는 작업은 데이터 파일의 레코드 저장 위치가 변경돼야 함 → 테이블 리빌드 필요 
      - 컬럼 이름 변경 → 리빌드 불필요 
    - 스키마 변경 중에도 R/W 모두 가능 
      - 최초 시작 지점과 마지막 종료 시점에는 R/W 불가능
      - 이 시간은 매우 짧아, 다른 커넥션의 쿼리 처리에 영향도가 높지 않음 
    - `NONE` or `SHARED` 락 사용 
  - `COPY`
    - 변경된 스키마를 적용한 임시 테이블을 생성 
    - 테이블의 레코드를 모두 임시 테이블로 복사 
    - 임시 테이블을 RENAME해서 스키마 변경을 완료 
    - 테이블 읽기만 가능하고, DML은 실행 불가
- `ALTER TABLE ... ALGORITHM=INPLACE, LOCK=NONE`와 같이 사용 가능 
- LOCK 
  - `NONE` : 락을 걸지 않음
  - `SHARED` : 읽기 잠금을 걸고 스키마 변경 실행 → 읽기는 가능하나 쓰기는 불가
  - `EXCLUSIVE` : 쓰기 잠금을 걸고 스키마 변경 실행 → 읽기/쓰기 모두 불가능
- `INPLACE` 알고리즘을 사용하는 경우
  - Data Reorganizing(Table Rebuild)이 필요한 경우 
    - 락을 필요로 하지 않음 → 읽고 쓰기 가능 
    - 테이블 레코드 건수에 따라 상당한 시간 소요 가능 
  - 필요 없는 경우
    - `INPLACE` 알고리즘을 사용하지만, `INSTANT`알고리즘과 비슷하게 매우 빨리 작업이 완료될 수 있음 
- 스키마 변경 작업은 실행 전에 매뉴얼과 테스트를 진행해볼 것 

### 온라인 처리 가능한 스키마 변경 
- 모든 스키마 변경 작업이 온라인으로 가능한게 아님 
- 꼭 확인!
  - 온라인 처리가 가능한지
  - 읽기 쓰기가 대기하게 되는지
- 가능한 알고리즘 종류 
  - 책 11.7.1.2 또는 MySQL 매뉴얼 참고

### INPLACE 알고리즘
- 테이블 리빌드가 발생할 때 
  1. INPLACE 스키마 변경이 지원되는 스토리지 엔진의 테이블인지 확인
  2. INPLACE 스키마 변경 준비 
     - 변경 정보 준비 
     - 온라인 DDL 작업 동안 변경되는 데이터를 추적할 준비
  3. 테이블 스키마 변경 및 새로운 DML 로깅
     - 실제 스키마 변경을 수행하는 과정 
     - 작업 수행 동안, 다른 커넥션의 DML 작업이 대기하지 않음 (즉시 처리)
     - 스키마 온라인 변경 + 다른 스레드는 사용자에 의해 발생한 DML들에 대해 별도의 로그로 기록 (Online alter log)
       - 로그는 디스크가 아니라 메모리에만 생성 
       - 할당되는 메모리 크기는 세션 단위의 동적 변수 → 필요한 경우 언제든 변경 가능 
  4. 로그 적용
     - 온라인 DDL 작업 동안 수집된 DML 로그를 테이블에 적용 
  5. INPLACE 스키마 변경 완료 (COMMIT)

- 2, 4번 단계에서는 잠깐의 배타적 잠금(Exclusive lock)이 필요함 
  - 해당 시점에는 다른 커넥션들의 DML이 잠시 대기 

### 실패 케이스 
- `INSTANT` 알고리즘은 거의 시작과 동시에 작업이 완료되므로 실패할 가능성이 거의 없음 
- `INPLACE`는 중간 실패 가능성이 상대적으로 높음
  - 테이블 리빌드, 최종 로그 적용 과정이 필요하기 때문 
- 최대한 온라인 DDL이 실패할 가능성을 낮추자
- 실패 케이스 
  - `ALTER TABLE` 명령이 장시간 실행되고, 동시에 다른 커넥션에서 DML이 많이 실행되는 경우
  - 온라인 변경 로그 공간이 부족한 경우 
  - `ALTER TABLE` 명령이 실행되는 동안 `ALTER TABLE` 이전 버전의 테이블 구조에서는 문제가 없었지만, `ALTER TABLE` 이후의 테이블 구조에는 적합하지 않은 레코드가 INSERT되거나 UPDATE 될 경우 
  - 스키마 변경을 위해 필요한 잠금 수준보다 낮은 잠금 옵션이 사용된 경우 
  - 온라인 스키마 변경은 `LOCK=NONE`으로 실행되어도, 변경 작업의 처음과 마지막 과정에서 락이 필요한데, 락을 획득하지 못하고 타임 아웃이 발생하는 경우
    - 테이블 수준의 메타 데이터 락이 필요. 이는 `lock_wait_timeout` 시스템 변수에 의해서 결정됨. 
  - 온라인으로 인덱스를 생성하는 작업의 경우, 정렬을 위해 tmpdir 시스템 변수에 설정된 임시 디렉터리를 사용 하는데, 이 공간이 부족한 경우

### 온라인 DDL 진행 상황 모니터링 
- 온라인 DDL 포함, 모든 `ALTER TABLE` 명령은 `performance_schema`를 통해 진행 상황 모니터링 가능
