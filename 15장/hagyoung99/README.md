# 15 데이터 타입

- 칼럼의 데이터 타입과 길이를 선정할 때 주의할 사항
  - 저장되는 값의 성격에 맞는 최적의 타입 선정
  - 가변 길이 칼럼은 쵲거의 길이를 지정
  - 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입으로 선정
- 칼럼의 길이와 크기가 무분별하게 선정되면 메모리와 자원이 낭비되며, SQL 성능이 저하된다.
- 칼럼의 길이와 타입 변경에도 문제가 발생할 수 있기 때문에 처음부터 정확히 분석해 선정하는게 중요하다.

## 15.1 문자열 (CHAR와 VARCHAR)
### 15.1.1 저장 공간
- CHAR
  - 고정길이로 실제 어떤 크기의 값이 들어와도 저장공간의 크기가 변하지 않는다.
- VARCHAR
  - 가변길이로 최대 값은 지정되어있지만 그 이내의 값이 들어올 경우 그만큼의 저장공간이 줄어든다.
  - 저장된 값의 유효 크기 확인을 위해 1~2바이트의 저장공간이 추가로 필요하다.
  - 작은 값에서 큰 값으로 변경될 때는 공간을 옮겨서 다시 저장해야한다.
- 고정된 길이의 값이나 값이 자주 변경될 수 있는 값들은 CHAR 타입을 사용하는게 좋다.
- CHAR 나 VARCHAR 키워드 뒤 숫자 값은 문자의 수를 의미한다.
### 15.1.2 저장 공간과 스키마 변경
- 칼럼의 길이를 63에서 64로 늘릴 때는 COPY 알고리즘 사용으로 시간이 오래 걸리며 읽기잠금을 필요로 한다.
### 15.1.3 문자 집합(캐릭터 셋)
- 사용 가능한 문자 집합은 `SHOW CHARACTER SET` 명령으로 확인이 가능하다.
- 한국에서 MySQL을 사용한다면 대부분 euckr / utf8mb4 를 사용한다.
- utf8mb4
  - 다국어 문자를 포함할 수 있는 칼럼에 사용하기 적합
  - 이모지 사용에도 해당 타입으로 사용
  - 해당 문자셋으로 생성시 한 글자 저장을 위해 1~4 바이트까지 사용하지만 메모리에 기록될 때는 문자열의 길이와 상관 없이 문자당 4바이트로 할당되는 경우가 있다.
#### 15.1.3.1 클라이언트로부터 쿼리를 요청했을 때의 문자 집합 변환
- SQL 문장에서 별도의 문자 집합을 설정하는 지정자를 `인트로듀서`라고 한다.
- 비교할 값에 대해 `_` + 문자셋 을 설정해주면 해당 문자셋으로 변환 후 비교 실행한다.
### 콜레이션(Collation)
- 문자열 칼럼 값에 대한 비교나 정렬 순서를 위한 규칙을 의미
- MySQL의 모든 문자열 타입은 독립적인 문자 집합과 콜레이션을 가진다.
#### 15.1.4.1 콜레이션 이해
- 사용 가능한 콜레이션 목록은 `SHOW COLLATION` 명령으로 확인할 수 있다.
- 3개의 파트로 구성된 콜레이션 이름
  - 첫번째는 문자 집합의 이름, 두번재는 해당 문자 집합의 하위 분류, 세번재는 대문자/소문자의 구분 여부(ci면 구분X/cs면 구분)
- 2개의 파트로 구성된 콜레이션
  - 첫번재는 문자 집합의 이름, 두번째는 이진 데이터인 `bin`은 이진 데이터를 의미
- 동일한 타입이어도 콜레이션이 다르다면 다른 타입으로 생각한다.
- 문자 집합과 콜레이션은 DB 수준, 테이블 수준, 칼럼 수준에서 개별적으로 설정할 수 있다.

#### 15.1.4.2 utf8mb4 문자 집합의 콜레이션
- 콜레이션은 필요에 따라 결정해야하는 부분, 성능을 기준으로 선택하지 않아야한다.
- 새로 프로젝트를 진행한다면 `utf8mb4_0900_ai_ci` 콜레이션 사용을 권장한다.

### 15.1.5 비교 방식
- `utf8mb4_0900_bin` 콜레이션 사용 이후 문자열 뒤의 공백도 문자열로 인식한다.
  - 다른 콜레이션에서는 문자열의 뒤는 잘라내고 비교하는 경우가 많다.
- information_schema 데이터베이스의 COLLATIONS 뷰에서 PAD_ATTRIBUTE 칼럼의 값으로 판단 가능
  - PAD SPACE 라면 비교 대상 문자열의 길이가 같아지도록 문자열 뒤에 공백을 추가해서 비교를 수행
  - NO PAD 라면 문자열의 길이를 맞추지 않고 그대로 비교한다.
  - 대부분의 콜레이션은 PAD SPACE 며, utf8mb4_0900 인 경우만 NO PAD 이기 때문에 utf8mb4_0900 사용시 주의해야한다.
  - 단, LIKE 에서는 공백 문자를 유효 문자로 취급한다.

### 15.1.6 문자열 이스케이프 처리
- SQL 문장에 사용하는 문자열은 프로그래밍 언어처럼 `\`를 사용해 이스케이프 처리가 가능하다.
- 홑따옴표와 쌍따옴표의 경우 두번 연속 표시나 홑따옴표를 쌍따옴표로 감싸거나 반대의 경우에 사용할 수 있다.
  - 홑따옴표로 문자열을 감쌀때 쌍따옴표 두번 연속 표기는 이스케이프로 인식되지 않는다. 반대도 마찬가지


## 15.2 숫자
- 숫자 저장 타입의 구분
  - 정확도
    - 참값: 소수점 이하 값의 유무와 관계없이 정확히 그 값을 유지하는 것
      - INTEGER, INT, DECIMAL
    - 근사값: 부동 소수점, 칼럼에 저장한 값과 조회된 값이 정확하게 일치하지 않고 최대한 비슷한 값으로 관리
      - FLOAT, DOUBLE
  - 저장되는 포맷
    - 이진 표기법: 정수나 실수타입, 256까지의 숫자를 표현할 수 있어 적은 메모리와 디스크 공간에 저장할 수 있다.
      - INTEGER, BIGINT 등의 대부분 숫자 타입이 이진 타입
    - 십진 표기법(DECIMAL): 숫자 값의 각 자릿값 표현을 위해 4비트나 한 바이트를 사용해 표기하는 방법
      - 디스크나 메모리에 십진 표기법으로 저장되는것을 의미
      - DECIMAL 만 사용하며 돈 같은 소수점까지 관리되어야하는 값이나 BIGINT 로도 저장할 수 없는 큰 값을 저장할 때 사용한다.
### 15.2.1 정수
- TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 가 있다.
- 입력이 가능한 수의 범위 내에서 최대한 저장 공간을 적게 사용하는 타입을 선택한다.
- UNSIGNED 옵션으로 설정시 양수만 저장, 미설정시 양수 음수 둘 다 저장할 수 있다.
  - 옵션 설정 시 양수만 저장하기 때문에 최대값이 2배가 더 커진다.
### 15.2.2 부동 소수점
- 숫자 값의 길이에 따라 유효 범위의 소수점 자릿수가 바뀐다.
- 정확한 유효 소수점 값을 식별하기 어렵고, 그 값으로 비교하기 어려우며 동등비교는 사용할 수 없다.
- 부동 소수점을 저장해야한다면 유효 소수점의 자리수만큼 10을 곱해 정수로 만들어 저장하는 방법이 있다.
  > 이게 좋을까..?
### 15.2.3 DECIMAL
- 소수점의 위치가 가변적이지 않은 고정 소수점을 저장할 때 사용한다.
- 저장하는 숫자의자리수/2 의 결과값을 올림 처리한 만큼의 바이트 수 필요
- 고정 소수점에만 사용하는게 공간활용에 좋다. 정수에 사용하는건 비효율적임
### 15.2.4 정수 타입의 칼럼을 생성할 때의 주의사항
- FLOAT이나  DOUBLE 타입은 저장공간의 크기가 고정이기 때문에 정밀도 조절로 저장공간의 크기가 바뀌지는 않는다.
- DECIMAL 타입은 저장공간의 크기가 가변적인 타입이라 저장가능한 자릿수 결정과 동시에 저장 공간의 크기까지 제한한다.
### 15.2.5 자동 증가(AUTO_INCREMENT) 옵션 사용
- 서버의 auto_increment_increment와 auto_increment_offset 설정을 통해 자동 증가값 설정이 가능하다.
- 각 스토리지 엔진에서 증가 패턴이 다르다.
  - MyISAM: 자동 증가 옵션이 사용된 칼럼이 프라이머리키나 유니크 키의 아무위치에나 사용 가능
  - InnoDB: AUTO_INCREMENT 칼럼으로 시작되는 인덱스 생성 필수

## 15.3 날짜와 시간
- MySQL 5.6 부터는 TIME 타입과, DATETIME, TIMESTAMP 탕비은 밀리초 단위의 데이터가 저장이 가능해졌다.
- 칼럼 공간의 크기는 밀리초 단위를 몇자리 까지 저장하느냐에 따라 달라진다.
- 밀리초 단위 저장을 위해서는 타입뒤에 괄호와 함께 숫자를 표기
- NOW() 함수 사용시에도 괄호 안에 숫자를 입력해야 현재 시간의 밀리초를 가져온다. 미입력시 밀리초는 0으로 반환된다.
- DATETIME, DATE 타입은 현재 DMBS 커넥션의 타입존과 관계 없이 클라이언트로부터 입력된 값을 그대로 저장하고 반환한다.
- TIMESTAMP 는 항상 UTC 타입존으로 저장되어, 타입존이 달라지면 해당 시차를 자동으로 보정해 반환한다.
- 타임존 관련 설정은 문제 발생시 해결이 어렵기 때문에 실행 전 충분한 테스트를 진행하는게 좋고 최대한 타임존 변경은 하지 않는게 좋다.
### 15.3.1 자동 업데이트
- 데이트 타입 뒤에 `DEFAULT CURRNET_TIMESTAMP` 옵션 사용시 INSERT 시 자동으로 날짜가 들어가고,
- `UPDATE CURRENT_TIMESTMP` 옵션 설정시 UPDATE 될 때 자동으로 들어간다.

## 15.4 ENUM과 SET
- 문자열의 값을 내부적으로 숫자 값으로 매핑해 관리하는 타입
### 15.4.1 ENUM
- 테이블의 구조에 나열된 목록 중 하나의 값을 가질 수 있다.
- 문자열이 길수록 저장공간을 더 많이 절약할 수 있지만 칼럼에 저장되는 문자열 값이 테이블 구조가 되면서 기존 타입에 새로운 값을 추가해야할때 테이블의 구조도 변경해야한다.
  - 마지막에 추가되는 형태라면 테이블의 구조 변경만으로 즉시 완료된다.
### 15.4.2 SET
- SET은 하나의 칼럼에 1개 이상의 값을 저장할 수 있다.
- 8개씩 1바이트로 최대 8바이트까지 저장공간을 사용할 수 있다.

## 15.5 TEXT와 BLOB
- 대량의 데이터를 저장할 때 사용
- TEXT 타입은 문자열을 저장하는 칼럼이라 문자집합이나 콜레이션을 가지고, BLOB 타입은 이진 데이터 타입으로 문자집합과 콜레이션을 가지지 않는다.
- 두 타입 다 대용량 타입이기 때문에 사용할 때 주의하고, 남용해서는 안된다.
- 사용할 수 있는 상황
  - 컬럼 하나에 저장되는 문자열이나 이진 값의 길이가 예측할 수 없이 큰 경우
  - 레코드 전체의 크기가 64KB를 넘어서 더 큰 컬럼을 추가할 수 없다면 일부 컬럼을 TEXT/BLOB 타입으로 전환해야할 수도 있다.
- BLOB/TEXT 칼럼이 포함된 INSERT/UPDATE 문장이 너무 길어져서 오류가 발생할 수 있기 때문에 대용량 데이터를 저장할 때는 MySQL 서버의 max_allowed_packet 시스템 변수를 늘려 설정해야한다.
- 데이터가 저장되는 방식
  - 6000바이트 미만이면 프라이머리 키 페이지에 같이 저장
  - 칼럼의 길이가 너무 긴 경우 해당 칼럼은 외부 페이지에 저장하고, 아닌 칼럼은 프라이머리 키 페이지에 같이 저장
  - 모두가 긴 경우 모두 외부 페이지에 저장하는데 길이가 16KB가 넘는 경우 칼럼 값을 나눠 여러개의 외부 페이지에 저장 후 각 페이지를 체인으로 연결해 보여준다.

## 15.6 공간 데이터 타입
- POINT, LINESTRING, POLYGON, GEOMETRY
  - 하나의 단위 정보만 저장할 수 있다.
- MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION
  - 종류별로 여러개의 객체를 저장할 수 있다.
- 저장하고자 하는 공간 데이터가 점, 선, 다각형 등으로 다양한 경우 GEOMETRY/GEOMETRYCOLLECTION 을 사용한다.
- GEOMETRY 타입은 MySQL 서버의 메모리에서 BLOB 객체로 관리및 전송된다.


## 15.7 JSON 타입
- MongoDB와 같이 바이너리 포맷으로 변환해 저장
### 15.7.1 저장방식
- 내부적으로 JSON 타입의 값을 BLOB 타입에 저장하지만 사용자가 입력한 값 그대로가 아닌 바이너리 포맷인 BSON 타입으로 변환해 저장한다.
### 15.7.2 부분 업데이트 성능
- JSON 칼럼의 부분 업데이트 기능은 JSON_SET()/JSON_REPLACE() 함수를 통해 변경하거나 삭제할 수 있다.
- 단순 정수 필드의 변경은 부분 업데이트가 적용되지만 문자열 타입의 필드는 길이에 따라 부분 업데이트 사용이 안될 수 있기 때문에 길이가 자주 변경된다면 최대 길이로 초기화하거나 애플리케이션에서 패딩해 고정길이로 만드는게 좋다.
### 15.7.3 JSON 타입 콜레이션과 비교
- utf8mb4 문자집합과 utf8mb4_bin 콜레이션을 가지기 때문에 JSON 칼럼의 비교와 JSON 칼럼으로부터 가공된 문자열은 대소문자, 엑센트 문자등도 구분해 비교한다.
### 15.7.4 JSON 칼럼 선택
- JSON 문자열을 JSON 칼럼에 저장하면 부분 업데이트를 이용한 빠른 변경과 JSON 데이터 가공에 필요한 여러 기능을 제공해준다.
- 따라서 JSON 데이터 저장시에는 BLOB/TEXT 보다 JSON 타입을 선택하는게 좋다.
- JSON 컬럼과 정규화된 칼럼을 비교할 경우 정규화된 칼럼이 성능적으로 이점을 가지고 있기 때문에 정규화된 컬럼 사용이 좋다.
  - JSON 컬럼은 필드의 이름을 따로 저장해야하기 때문
  - 압축은 디스크의 공간만 줄일뿐 메모리 효율을 높여주지는 못해서 의미가 없다.
  - 정규화된 컬럼 사용시 대용량 데이터를 외부 페이지로 관리가 가능하다.
  - 레코드의 각 속성들이 너무 상이하고, 다양해 정규화가 어려울 경우 JSON 컬럼에 저장하는게 좋다.
    - JSON 칼럼에 저장되는 속성들은 중요도가 낮을수록 좋다.(검색 조건으로 사용될 가능성이 낮은 데이터)
  - 중요도가 낮은 정규화된 테이블 구조를 JSON 칼럼에 넣는것도 방법이다.


## 15.8 가상 칼럼(파생 칼럼)
- MySQL 서버에서는 'Generated Column' 이라는 이름으로 소개
- 데이터의 종류를 한정하지 않지만 칼럼을 정의하는 방법중 하나이다.
- 다른 칼럼의 값을 참조해 새로운 값을 만들어 관리한다.
- 가상칼럼
  - 칼럼의 값이 디스크에 저장되지 않음
  - 칼럼의 구조 변경은 테이블 리빌드를 필요로 하지 않음
  - 칼럼의 값은 레코드가 읽히기 전 또는 BEFORE 트리거 실행 직후 계산되어 생성됨
- 스토어드 칼럼
  - 칼럼의 값이 물리적으로 디스크에 저장
  - 칼럼의 구조 변경은 다른 일반 테이블과 같이 필요 시 테이블 리빌드 방식으로 처리
  - INSERT와 UPDATE 시점에만 칼럼의 값이 계산
- 함수 기반의 인덱스는 가상 칼럼에 인덱스를 생성하는 방식으로 작동한다.