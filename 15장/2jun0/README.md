# 15 데이터 타입

## 15.1 문자열 (CHAR, VARCHAR)

### 저장 공간 (칼럼이 필요한 공간)

같은 길이일때 VARCHAR가 더 많이 차지한다.

- CHAR: 고정 길이! (n 바이트)
- VARCHAR: 실제 길이 + 최대 길이 (n+1~n+2 바이트)

#### CHAR / VARCHAR 선택 기준

- 저장되는 문자열의 길이가 대개 비슷한가?
- 칼럼의 값이 자주 변경되는가?
  - CHAR

VARCHAR는 미리 최대 공간을 할당하지 않는다. 따라서 크기가 바뀌면 레코드를 다른 공간으로 옮긴다.

#### 주의 사항

VARCHAR가 TEXT로 변환되었는지 확인하자!

- 하나의 레코드에서 TEXT와 BLOB을 제외한 칼럼의 전체 크기가 64KB를 초과할 수 없다.
- 이미 40KB를 사용하고 있고, VARCHAR가 40KB를 사용하고자 해서 총 크기가 64KB를 초과하면 TEXT으로 자동변환된다.

VHARCHAR와 CHAR의 바이트 크기를 주의하자!

- VARCHAR와 CHAR에 지정하는 숫자는 문자의 수를 의미한다.
- 그래서 2, 4바이트 문자도 들어간다!

### 스키마 변경 (Online DDL)

VHARCHAR의 크기를 변경할때 공유잠금이 걸릴 수 있다.

- VARCHAR을 63 -> 64, 64 -> 63으로 변경할때 발생할 수 있다.
- 길이를 저장하는 공간이 1 -> 2, 2 -> 1으로 변경되기 때문.
- 나머지 상황은 빠르게 처리된다.

### 문자 집합(캐릭터 셋)

_이거 중요한가?_

- 테이블 단위로 문자 인코딩을 지정할 수 있다.
- 한글은 UTF-8과 EUC-KR을 지원한다.
  - 윈도우에서 사용하는 CP949 인코딩은 지원하지 않는다.
  - 대신 EUC-KR을 쓰면 호환된다

### 콜레이션(Collation)

콜레이션이 뭔데?

- 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미한다.
- 모든 문자열 타입의 칼럼은 독립적으로 문자 셋과 콜레이션을 가진다.
- `SHOW COLLATION`으로 가능한 콜레이션 목록을 볼 수 있다.

_바꾸면 애플리케이션과 정렬 순서가 다르게 될 텐데 괜찮을까?_

### 비교 방식

CHAR 타입에서 사용되지 않는 공간은 뒤에 공백 문자가 채워져서 비교한다.

- `SELECT 'ABC'='ABC   ';`는 참이다.
- `SELECT 'ABC'='   ABC';`는 거짓이다.
- 크다 작다도 이렇게 처리한다.

하지만, UCA 9.0.0인 uft8mb4_0900_bin 콜레이션은 뒤의 공백이 비교결과에 영향을 미친다.

- `SET NAMES utf8mb4 COLLATE utfmb4_0900_bin;`
- `SELECT 'ABC'='ABC   ';`는 거짓이다.

LIKE를 사용한 문자열 비교에서는 공백 문자를 유효 문자로 처리한다.

- `SELECT 'ABC   ' LIKE 'ABC';`는 거짓이다.
- `SELECT 'ABC   ' LIKE 'ABC%';`는 참이다.

다른 DBMS에서는 MySQL의 문자열 비교방식과 다를 수 있으니 주의하자.

### 문자열 이스케이프 처리

- ', "문자에 대해서 이스케이프를 '', ""로 할수 있다. (_...이건 좀.._)

## 15.2 숫자

용어 정리

- 참값(Exact value): 정확한 값 INTEGER, DECIMAL등
- 근사값: 부동 소수점을 이용한 값 FLOAT, DOUBLE등

### DECIMAL?

- 십진표기법(DECIMAL)은 숫자 각 자리값을 4비트나 8비트(1바이트)를 사용한다.
- 메모리에 십진 표기법으로 저장된다고 생각하자.
- 돈과 같은 민감하게 다뤄야 하는 숫자를 소수점까지 정확한 값을 저장할때 사용한다.
  - 정밀도 명시: `DECIMAL(총 자리수, 소수 자리수)`
- 65자리 숫자까지 표현할 수 있다.

### 정수

- UNSIGNED를 붙일 수 있다.
- AUTO_INCREMENT에 적용하면 이득
- SIGNED와 UNSIGNED를 조인할때 문제가 없다. (인덱스를 사용하지 못하고 그런 이슈 없음)

### 부동 소수점

- 동등 비교 사용할 수 없다.
- FLOAT는 정밀도를 명시하지 않으면 4바이트를 사용해 유효 자릿수를 8개까지 유지한다. (정밀도 명시하면 8바이트 까지)
- DOUBLE은 8바이트, 16바이트
- 레플리카 서버에서 부동소수점은 소스서버와 다를 수 있다.

## 15.3 날짜와 시간

### 저장공간

- TIME / DATETIME / TIMESTAMP는 밀리초 단위를 몇 자리까지 저장하느냐에 따라 저장공간이 달라진다.
- 2자리당 1바이트씩 필요하다. (DECIMAL과 같은 원리인가?)

### 타임존

- 날짜 칼럼에는 타임존이 저장되지 않는다.
- DATETIME / DATE는 입력된 값을 그대로 저장하고, 조회도 그대로 반환한다.
- TIMESTAMP는 항상 **UTC**로 저장된다.
  - 세션의 타임존에 따라 값이 자동으로 보정된다.

### CREATED_AT, UPDATED_AT

_꼭 이렇게 해야 할까?_

- created_at, updated_at을 mysql에서 지원한다.
- 테이블을 생성할때 아래와 같이 칼럼을 정의하면 된다.
- TIMESTAMP와 DATETIME 모두 가능하다.
- `created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP`
- `updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`

## 15.4 ENUM / SET

### ENUM

_대충 문자열 칼럼보다 좋아요~ 라는 내용_

### SET

_대충 ENUM인데 하나의 칼럼에 1개 이상의 값을 저장할 수 있다는 내용_
_비트마스킹을 활용한다고 함_

## 15.5 TEXT / BLOB

둘은 대량의 데이터를 저장한다는 관점에서 비슷하다.  
둘의 차이는 아래와 같다.

- TEXT: 문자 셋과 콜레이션을 가진다.
- BLOB: 그런거 없다.

이진 데이터와 문자열을 저장하기 위한 데이터 타입

|             | 고정길이 | 가변길이  | 대용량 |
| ----------- | -------- | --------- | ------ |
| 문자 데이터 | CHAR     | VARCHAR   | TEXT   |
| 이진 데이터 | BINARY   | VARBINARY | BLOB   |

인덱스 레코드의 모든 칼럼은 최대 제한 크기가 있다 주의하자

## 15.8 가상 칼럼(파생 칼럼, Generated Column)

MySQL서버의 가상 칼럼은 크게 가상 칼럼(Virtual Column)과 스토어드 칼럼(Stored Column)으로 나뉜다.

- 가상 칼럼
  - ex) `total_price DECIMAL(10, 2) AS (quantity * price) VIRTUAL`
  - 칼럼의 값이 디스크에 저장되지 않음
  - 구조 변경은 테이블 리빌드가 필요하지 않음
  - 레코드가 읽히기 전 또는 BEFORE 트리거 실행 직후에 계산됨
- 스토어드 칼럼
  - ex) `total_price DECIMAL(10, 2) AS (quantity * price) STORED`
  - 칼럼의 값이 물리적으로 디스크에 저장
  - 칼럼의 구조 변경은 다른 일반 데이블과 같이 필요시 테이블 리빌드로 처리됨
  - INSERT / UPDATE 시점에만 칼럼의 값이 계산됨
