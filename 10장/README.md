# 10.1 통계 정보 
## 10.1.1 테이블 및 인덱스 통계 정보 
- 비용 기반 최적화에서 가장 중요한 것은 통계 정보 

### 10.1.1.1 MySQL 서버의 통계 정보 
- InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 테이블의 형태로 저장함 
  - 의도하지 않은 통계 정보 변경을 막을 수 있음 
  - 통계 정보 자동 갱신 (`innodb_stats_auto_recalc`)을 `OFF`로 변경하면 자동 갱신을 막을 수 있음 → 영구적인 통계 정보를 이용하고자 할 때 사용 
- 정확한 통계 정보를 수집하는 것이 쿼리 성능에 도움이될 수 있음
  - 서버 점검, 사용량이 많지 않은 시간을 이용해 정확한 정보를 수집 


## 10.1.2 히스토그램 
- 컬럼의 데이터 분포도를 참조할 수 있는 정보 

### 10.1.2.1 히스토그램 정보 수집 및 삭제 
- 히스토그램 정보는 컬럼 단위로 관리됨 
- `ANALYZE TABLE` 명령을 통해 수동으로 수집 및 관리 
  - 시스템 딕셔너리에 함께 저장 
  - MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` 스키마의 `column_statistics` 테이블에 로딩
- 히스토그램은 Bucket 단위로 구분되어 관리됨
- 2 종류의 히스토그램 타입
  - ![img.png](img.png)
  - `Singleton`
    - 컬럼 값 개별로 레코드 건수 관리 
      - 컬럼 값 별로 버킷 할당 
      - 버킷 구성: 컬럼 값 + 발생 빈도 비율 
    - 누적 값이 표현됨 
      - 그림 상에서 `M` = 0.5998 , `F` = 1 - 0.5998
    - value-based 히스토그램 or 도수 분포도 
  - `Equi-Height`
    - 컬럼 값의 범위를 균등한 개수로 구분해서 관리
      - 개수가 균등한 컬럼값의 범위 별로 하나의 버킷 할당
      - 버킷 구성: 범위 시작 값 + 마지막 값 + 발생 빈도 비율 + 버킷에 포함된 유니크한 값의 개수
    - 컬럼 값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시됨 
      - 그림 상에서 기울기가 일정한것을 보면 각 범위가 비슷한 값의 레코드 건수를 가진다는 것을 알 수 있음 
    - Height-Balanced 히스토그램 


### 10.1.2.2 히스토그램의 용도 
- 실제 응용 프로그램 데이터는 항상 균등한 분포도를 가지지 않음 
- 히스토그램을 이용해 데이터 분포도를 파악하고, 이를 이용해 쿼리 실행 계획을 수립할 수 있음
  - 버킷 별 레코드 건수, 유니크한 값의 개수 정보 등을 가지기 때문에 더 정확한 예측이 가능 
- 히스토그램 정보가 없으면, 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측함
- 히스토그램이 있으면, 특정 범위의 데이터가 많고 적음을 식별할 수 있음 
  - 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 더 정확히 판단 가능 


### 10.1.2.3 히스토그램과 인덱스 
- 인덱스 다이브
  - 사용 가능한 인덱스들로 부터 조건절에 일치하는 레코드 건수를 대략 파악하기 위해 실제 인덱스의 B-Tree를 샘플링해서 살펴보는 것 
- 인덱스된 컬럼에 대해 히스토그램 정보를 수집 해두는 것이 좋을까?
  - 인덱스된 컬럼을 검색 조건으로 사용하는 경우, 해당 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 수집한 정보를 활용함 
  - 이는 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것 → 항상 히스토그램보다 정확한 결과를 기대할 수 있음 
  - 따라서, 히스토그램은 주로 **인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도**로 사용함 
- 인덱스 다이브는 어느 정도의 비용이 필요함 
  - `IN` 절에 값이 많이 명시된 경우, 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행함 (비용 증가)


## 10.1.3 코스트 모델
- 코스트 모델
  - 쿼리 처리 비용을 계산하는 데 필요한 단위 작업들의 비용 
- 쿼리 처리에 필요한 작업들 
  - 디스크로부터 페이지 읽기
  - InnoDB 버퍼 풀로부터 데이터 페이지 읽기
  - 인덱스 키 비교 
  - 레코드 평가 
  - 메모리 임시 테이블 작업 
  - 디스크 임시 테이블 작업 
- 위 작업들이 얼마나 필요한지 예측 → 전체 작업 비용 계산 → 최적의 실행 계획

### MySQL 8.0 서버의 코스트 모델 
- `server_cost`: 인덱스를 찾고, 레코드를 비교하고, 임시 테이블 처리에 대한 비용을 관리 
- `engine_cost`: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용을 관리

### 코스트 모델에서 중요한 것 
- 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고, 어떤 실행 계획들이 저비용으로 바뀌는지를 파악해야 함

### 각 단위 작업 비용이 변경되면 예상할 수 있는 결과 
- `key_compare_cost`↑
  - 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성 ↑
- `row_evaluate_cost`↑
  - 풀 스캔을 사용하는 쿼리들의 비용 ↑ 
  - 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성 ↑
- `disk_temptable_create_cost`↑
  - 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성 ↑
- `memory_temptable_create_cost`↑
  - 메모리에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성 ↑
- `io_block_read_cost`↑
  - InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성 ↑
- `memory_block_read_cost`
  - 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성 ↑

---

---

# 10.2 실행 계획 확인 
- `DESC`, `EXPLAIN` 명령으로 확인 

## 10.2.1 실행 계획 출력 포맷 
- 테이블 포맷
- 트리 포맷 
- JSON 포맷 

## 10.2.2 쿼리 실행 시간 
- `EXPLAIN ANALYZE` 명령으로 확인 가능
  - 기본이 Tree 포맷
- 실행 계획의 단계별로 소요된 시간 정보를 확인할 수 있음
- 읽는 방법 
  - 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
  - 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행
  - ex
    - ![img_1.png](img_1.png)


---

---

# 10.3 실행 계획 분석 
- 실행 계획에서는 아래 사항이 중요하다  
  - 어떤 접근 방법을 사용하여 어떤 최적화를 수행하는가 
  - 어떤 인덱스를 사용하는가 

## 10.3.1 id 
- `select` 쿼리별로 부여되는 식별자 값 
  - 단위 쿼리마다 `id` 값 부여 
    - 단위 쿼리
      - `select` 키워드 단위로 구분한 것 
- `join`
  - 조인되는 테이블 개수만큼 실행 계획 레코드가 출력됨
  - 같은 `id`값이 부여됨 
- 여러 개의 `select` 쿼리로 구성된 쿼리
  - 각각 다른 `id`값이 부여됨 
- `id`값이 테이블 접근 순서를 의미하지는 않음 


## 10.3.2 select_type
- 각 단위 `select` 쿼리가 어떤 타입인지 표시 

### simple
- union, 서브쿼리를 사용하지 않는 단순한 select 쿼리 
- 쿼리 문장이 아무리 복잡해도 실행 계획에서 simple인 단위 쿼리는 단 하나만 존재 

### primary
- union, 서브 쿼리가 있는 select 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 primary로 표시됨 
- 쿼리 문장이 아무리 복잡해도 실행 계획에서 primary인 단위 쿼리는 단 하나만 존재

### union
- union으로 결합하는 단위 select 쿼리 중, 첫 번째를 제외한 두 번째 이후 단위 select 쿼리의 select type은 union으로 표시 
  - union의 첫 번째 단위 select는 derived로 표시 (임시 테이블)\
  
### dependent union
- union, union all 로 집합을 결합하는 쿼리에서 표시됨 
- dependent는 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미 
  - 내부 쿼리가 외부의 값을 참조해서 처리될 때 표시됨 

### union result
- union 결과를 담아두는 임시 테이블을 의미 
  - union all은 임시 테이블을 사용하지 않으나, union, union distinct는 여전히 임시 테이블에 결과를 버퍼링함

### subquery
- `from`절 이외에서 사용되는 서브쿼리만을 의미 
  - `from`절의 서브쿼리는 `derived`로 표기 

> 서브 쿼리 사용 위치에 따른 이름
> - Nested Query: select되는 컬럼에 사용된 서브 쿼리 
> - Subquery: where 절에 사용된 서브 쿼리 
> - Derived Table: from 절에 사용된 서브 쿼리 (인라인 뷰, 서브 셀렉트)
> 
> 반환하는 값의 특성에 따른 구분
> - Scalar Subquery: 단일 값을 반환하는 서브 쿼리 (컬럼이 단 1개인 레코드 1건)
> - Row Subquery: 여러 개의 컬럼 값을 반환하는 서브 쿼리 (컬럼의 개수와 관계 없이 1개의 레코드)


### dependent subquery
- 서브쿼리가 바깥쪽 select 쿼리에서 정의된 컬럼을 사용하는 경우 
  - 즉, 안쪽의 서브쿼리 결과가 바깥쪽 select 쿼리의 컬럼에 의존적인 경우를 의미 
- 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행되어야 함 

### derived
- 단위 select 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성함
- 실행 계획을 join으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋음 
- 쿼리 튜닝 시 `derived`가 있는지를 먼저 확인한다 
  - 서브쿼리를 조인으로 해결할 수 있다면 조인을 사용할 것을 강력히 권장한다 

### dependent derived
- `from`절의 서브쿼리가 외부 컬럼을 참조하는 경우 (lateral join)

### uncacheable subquery
- 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우
  - 서브쿼리 결과 캐시  
    - 똑같은 서브쿼리가 여러번 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있는 기능
    - 쿼리 캐시와 derived와는 무관 

- 캐시를 사용하지 못하게 하는 요소 
  - 사용자 변수가 서브쿼리에 사용된 경우
  - not-deterministic 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우 
  - uuid(), rand()와 같이 호출할 때마다 결괏값이 달라지는 함수가 서브쿼리에 사용된 경우


### materialized
- from절이나 in(subquery) 형태의 쿼리에 사용된 서브 쿼리의 최적화를 위해 사용 
- 서브쿼리 내용을 임시 테이블로 구체화(materialize) 하여 사용 
  - 쿼리의 내용을 임시 테이블로 생성함 


## 10.3.3 table
- MySQl 실행 계획은 단위 select 쿼리 기준이 아닌, 테이블 기준으로 표시됨 
  - 테이블 이름에 별칭이 부여된 경우, 별칭이 표시됨 
- `<derived N>`, `<union M,N>`: 임시 테이블을 의미 
  - `<derived2>`: 단위 select 쿼리의 id값이 2인 실행 계획으로 부터 만들어진 파생 테이블


## 10.3.4 partitions
- 파티션 관련 정보를 나타냄 
- 특정 파티션에 해당되는 데이터만 조회할 경우, 특정 파티션만 사용함
  - 즉, 불필요한 파티션은 실행계획을 세울 때 고려하지 않음
  - 접근해야 할 것으로 판단되는 테이블만 골라내는 것을 파티션 프루닝이라고 함
    - 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가짐 


## 10.3.5 type
- 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타냄 (테이블 접근 방법) 
  - 인덱스를 사용했는지, 테이블 풀 스캔을 사용했는지...
- 인덱스를 효율적으로 사용하는지 여부를 알 수 있으므로 반드시 체크해야 할 중요 정보임 
- 표시될 수 있는 값
  - `system`
    - 레코드가 1건만 존재하는 테이블 or 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법 (MyISAM, MEMORY)
  - `const`
    - 조인 순서와 관계 없이 PK/Unique key의 모든 컬럼에 대해 동등(equal) 조건으로 검색 (반드시 1건의 레코드만 반환)
    - const 실행 계획은 옵티마이저가 쿼리 최적화 단계에서 쿼리를 먼저 실행해서 통째로 상수화 하기 때문에 붙여진 이름 
  - `eq_ref`
    - 여러 테이블이 조인되는 쿼리의 실행 계획에서 표시됨 
      - 조인에서 첫 번째 읽은 테이블의 컬럼 값을 이용해 두 번째 테이블을 PK/Unique key로 동등(equal) 조건 검색(두 번째 테이블은 반드시 1건의 레코드만 반환)
    - 즉, 조인에서 두 번째 이후에 읽는 테이블에서 **반드시 1건만 존재한다는 보장이 있어야만 사용 가능**함 
  - `ref`
    - 조인 순서, 인덱스 종류와 관계 없이 동등(equal) 조건으로 검색할 때 사용되는 접근법 (1건만 반환된다는 보장이 없어도 됨)
  - `fulltext`
    - 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근법
    - 실무 팁
      - Fulltext index 사용 금지
        - 전문 검색용 인덱스
        - 전반적으로 한계가 많은 기능
        - 인덱싱 데이터가 임계점을 넘어가면 재앙이 시작됨
          - 문제가 발생하면 튜닝으로는 해결도 안됨. 걍쓰지마셈
  - `ref_or_null`
    - `ref`와 같으나, `null`값을 포함하는 경우
    - 실제로는 많이 사용되지 않지만, 만약 사용될 경우 나쁘지 않은 접근 방법임 
  - `unique_subquery`
    - `where` 조건절에서 사용될 수 있는 `in(subquery)` 형태의 쿼리를 위한 접근 방법 
      - 서브쿼리는 지양하자.. 
  - `index_subquery`
    - `in(subquery)`에서 subquery가 중복된 값을 반환할 수도 있는 경우, 해당 중복 값을 인덱스를 이용해서 제거할 수 있는 경우 사용됨 
      - 서브 쿼리는 지양하자..
  - `range`
    - 인덱스 레인지 스캔 형태의 접근 방법 
      - 인덱스 레인지 스캔: `const`, `ref`, `range` 세 가지를 묶어 지칭하는 것임 
    - 값이 아닌, 범위로 인덱스를 검색하는 경우에 사용 (`<`, `>`, `between`, `like` 등)
    - 우선 순위가 낮으나, range 접근 방법도 상당히 빠르며, 최적의 성능이 보장되는 type임  
  - `index_merge`
    - 여러 개의 인덱스를 사용해 레코드를 읽어 각 검색 결과를 만든 후, 그 결과를 병합하여 처리하는 방식 
    - 여러 인덱스를 읽어야 하여 `range`보다 효율성이 떨어짐 
    - 항상 2개 이상의 집합 생성 → 교집합, 합집합, 중복 제거와 같은 부가적인 작업 필요 
  - `index`
    - 인덱스 풀 스캔을 의미
    - 아래의 경우 사용됨
      - `range`, `const`, `ref`와 같은 방법으로 인덱스를 사용하지 못하는 경우 
      - 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우 (데이터 파일을 읽지 않아도 될 때)
      - 인덱스를 이용해 정렬/그루핑 작업이 가능한 경우 
  - `ALL`
    - 테이블 풀 스캔을 사용해 레코드를 읽는 경우
      - 테이블을 처음부터 끝까지 읽어서 불필요한 레코드를 제거하고 반환 
    - 가장 마지막에 선택하는 가장 비효율적인 방법 
    - InnoDB: `Read Ahead`라는 기능을 제공 (한꺼번에 많은 페이지를 읽어들이는 작업 기능)
      - 인접한 페이지가 연속해서 몇 번 읽히면 백그라운드 읽기 스레드가 최대 64개의 페이지씩 한번에 디스크로부터 읽어들임 

- `const`, `eq_ref`, `ref`는 인덱스 분포도가 나쁘지 않다면 성능상 문제를 일으키지 않는 접근법임 
  - 크게 신경쓰지 않고 넘어가도 됨 
- `index`, `ALL`은 작업 범위를 제한하는 조건이 아님 
  - 빠른 응답을 사용자에게 보내야 하는 OLTP에서는 적합하지 않음 


## 10.3.6 possible_keys
- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록 
  - 그 인덱스를 사용하는 게 아님
  - 쿼리 튜닝하는 데 크게 도움은 안됨 

## 10.3.7 key
- 최종 선택된 실행 계획에서 사용하는 인덱스 
  - `PRIMARY`: PK를 사용했다는 의미 
  - 혹은 인덱스의 고유 이름이 표시됨 
- `type`컬럼이 `index_merge`인 경우에만 여러 개의 인덱스가 표시됨 

## 10.3.8 key_len
- 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값임
  - 사실 매우 중요한 정보 중 하나임 
  - ex: key_len=16 → 사용된 인덱스가 16byte라는 뜻  
- 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지를 우리에게 알려줌 (단일 컬럼 인덱스에서도 표시는 됨)
- 타입의 원래 길이보다 좀 더 길게 표기될 수 있음 
  - ex: `date`는 3byte인데 nullable하게 구성할 경우 4byte로 표시됨
    - 즉, MySQL에서는 NOT NULL이 아닌 컬럼에 대해서는 컬럼의 값이 NULL인지 아닌지를 저장하기 위해 1바이트를 추가로 더 사용함

## 10.3.9 ref
- 접근 방법이 `ref`일 때 참조 조건으로 어떤 값이 제공됐는지 보여줌 
  - 상수 값이면 `ref` 컬럼은 `const`로 표시됨 
  - 다른 테이블의 컬럼 값이면 테이블명과 컬럼명이 표시됨 
- 주의해서 보아야 할 케이스 
  - `func`인 경우 
    - 참조용으로 사용되는 값을 그대로 사용한게 아니라, 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미 
    - 이런 변환이 발생하지 않게 타입은 일치시키자 

## 10.3.10 rows
- 실행 계획의 효율성 판단을 위해 예측했던 레코드의 건 수  
  - 통계 정보를 참조해 MySQL 옵티마이저가 산출해낸 예상값 → 정확하지는 않음  
  - 대략의 수치에 어느 정도는 근접해야 옵티마이저가 최선의 실행 계획을 수립함 
- 반환하는 레코드의 예측치가 아님 
  - 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미 

## 10.3.11 filtered
- 테이블 조건으로 필터링되고 남은 레코드의 비율을 의미
  - 100: 행 필터링이 발생되지 않았음 
  - `rows` 검사된 예상 레코드 수 * `filtered` = 조인된 레코드 건 수 
    - ex: `rows = 1000`, `filtered = 50.00` → 1000건의 레코드 중 500건이 조인에 사용됨
- 조인의 횟수를 줄이고, 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해, 대상 건수가 적은 테이블을 드라이빙 테이블로 선택할 가능성이 높음 
  - 즉, `rows`가 적을수록, `rows` * `filtered / 100`가 적을수록 드라이빙 테이블로 선택될 확률이 높음  

## 10.3.12 Extra
- 성능에 관련된 중요한 내용이 해당 컬럼에 자주 표시됨
- `const row not found`
  - `const` 접근 방법으로 테이블을 읽었으나, 실제로 테이블에 레코드가 1건도 존재하지 않는 경우
- `deleting all rows`