# Introduction
- 복제를 구성한다고 고가용성이 실현되는 것은 아님 
  - 소스 서버에 장애가 발생했을 때 레플리카 서버가 **자동으로 기존 소스 서버를 대체하는 것이 새로운 소스 서버로 전환되는 것이 아니**기 때문 
- MySQL은 서버 자체적으로 자동 페일오버(Failover)를 처리하는 기능을 제공하지 않음
  - 장애 발생 시, 사용자가 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 함 
- 일련의 작업
  - 레플리카 서버에 설정된 읽기 모드를 해제 
  - 스블릿 브레인(Split-Brain) 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 함 
    - 스플릿 브레인?
      - 클러스터로 구성된 두 시스템 간의 네트워크가 일시적으로 동시에 단절되거나 기타 시스템상의 이유로, 클러스터 상의 모든 노드들이 각자 자신이 Primary라고 인식하게 되는 상황 
      - 아마 MySQL 복제에서는 두 서버 모두 자신이 소스 서버라고 인식하는 상황을 말하는 것 같다. 
  - 애플리케이션 서버가 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 함 
- 장애 시간을 최소화 하는 것이 중요하다 
  - 자동화를 고려해야 함 
  - 서드파티 MA 솔루션: MMM, MHA, Orchestrator 
  - MySQL 5.7.17 부터는 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입됨 


---

---

# 17.1 InnoDB 클러스터 아키텍처 
![img.png](img/img.png)
- InnoDB 클러스터는 MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체임 
- 구성 요소
  - 그룹 복제(Group Replication)
    - 소스 서버 데이터를 레플리카 서버로 동기화 하는 기본적인 복제 역할 
    - 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리(그룹에 새로운 멤버 추가/제거) 역할 
    - Primary 서버: 읽기/쓰기 모두 가능 (소스 서버) 
      - 1~N대 존재 가능 
    - Secondary 서버: 읽기만 가능 (레플리카 서버)
    - 최소 3대 이상의 서버가 필요 
      - 3대로 구성했을 때 부터 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상 동작하기 때문 
  - MySQL 라우터(MySQL Router)
    - 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램 
    - 애플리케이션이 실행한 쿼리를 적절한 MySQL 서버로 전달하는 Proxy 역할
      - InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타 데이터 정보를 가지고 있음 
      - 애플리케이션의 커넥션 정보에는 MySQL 라우터 서버만 설정해두면 됨 
  - MySQL 셸(MySQL Shell)
    - 기본적인 SQL문 실행 
    - js, python 기반의 스크립트 작성 기능 
    - MySQL 서버에 대해 클러스터 구성 등의 Admin 작업을 할 수 있게 하는 AdminAPI 제공
      - 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있음 
      - 클러스터 상태 확인, 서버 설정 변경 등 여러 기능 제공 
- 장애가 발생한 경우
  - 그룹 복제가 먼저 이를 감지함 
    - 자동으로 해당 서버를 복제 그룹에서 제외 
  - MySQL 라우터가 복제 토폴로지 변경을 인지
    - 서버 관련 메타데이터를 갱신하여 애플리케이션 서버에서 실행된 쿼리가 정상 동작하는 MySQL 서버로만 전달되도록 함 


---

---

# 17.2 그룹 복제(Group Replication)
- 내부적으로 ROW 포맷 바이너리 로그와 릴레이 로그, GTID를 사용 

## 17.2.0 기존 복제와 그룹 복제의 차이
### 복제 방향  
![img_1.png](img/img_1.png)
- 기존 복제: 소스-레플리카 형태로 구성되어 단방향으로만 복제 
- 그룹 복제: 그룹 내 서버들은 서로 통신하며 양방향 복제 처리 가능 (쓰기 처리 서버 여러대 존재 가능)

### 복제 처리 방식 
![img_2.png](img/img_2.png)
- 기존 복제: 비동기, 반동기 방식으로 나뉨 
  - 소스 서버에서의 트랜잭션 커밋 처리가 레플리카 서버와 무관하게 처리됨
  - 소스 서버에서는 트랜잭션이 커밋될 경우, 레플리카 서버에도 해당 트랜잭션이 잘 적용됐는지 확인하지 않음 (반동기에서 전달 정도만 확인함)
  - 레플리카 서버로부터 응답을 받지 못했다고 해서 트랜잭션이 소스 서버에서 적용되지 않는 것은 아님 
    - 소스 서버에서 일방적으로 적용 
- 그룹 복제: 반동기 방식이라고 할 수 있으나, 기존 반동기 방식과는 차이가 있음 
  - 한 서버에서 트랜잭션 커밋 준비 완료 → 트랜잭션 정보를 그룹의 다른 멤버들에게 전송 → 과반수 이상의 멤버로부터 응답을 받음(consensus) → 트랜잭션을 인증(certify) → 커밋 처리 
    - 인증 과정: 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 "충돌 여부"를 검사하고, 문제 없이 적용 가능한지 그 여부를 확인함 
    - 과반 수 이상의 멤버로부터 응답을 받지 못할 경우, 해당 트랜잭션은 그룹에 적용되지 않음
  - 그룹 내 멤버들의 응답에 따라 트랜잭션 적용 여부가 결정됨
    - 합의(consensus) 과정 이라고 함 
    - 데이터를 변경하는 트랜잭션에 대해서만 이같은 합의 과정이 필요함 (읽기에는 필요 없음)
  - 트랜잭션을 실제로 적용했는지는 확인하지 않음


### 대표 기능 
- 그룹 멤버 관리
- 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지 
- 자동 Failover
- 자동 분산 복구 


## 17.2.1 그룹 복제 아키텍처 
![img_3.png](img/img_3.png)
- 그룹 복제 플러그인을 통해 서로간에 지속적으로 통신하며 복제 동기화를 처리 
- 복제 채널을 통해 그룹에서 실행된 모든 트랜잭션을 전달받아 적용하게 됨 
- 그룹에 새로 가입할 경우, 이미 참여중인 다른 서버들과 같이 최신 데이터를 가지도록 하는 그룹 복제 분산 복구 작업 가능

![img_4.png](img/img_4.png)
- 그룹 복제 플러그인의 구성 
  - Plugin API: 그룹 복제 플러그인이 MySQL 서버와 상호작용 하기위한 인터페이스 
    - MySQL 서버에서는 서버의 시작 또는 복구, 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달함 
    - 그룹 복제 플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 등을 서버에 전달함 
  - Replication Plugin: 그룹 복제 기능들이 실질적으로 구현돼 있는 계층 
    - 여러 모듈로 나눠져 있음 
    - API로 들어온 요청들은 각각 적절한 모듈로 전달됨 
    - 로컬 및 그룹 복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리됨 
    - 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파 등이 수행됨 
    - 그룹 복제의 분산 복구 작업도 해당 계층에서 처리 됨 
  - 그룹 통신 시스템 API & 그룹 통신 엔진
    - 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소 
    - 그룹 통신 엔진은 트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장함 
    - 그룹 복제 토폴로지 변경과 그룹 멤버의 장애 등을 감지 
    - 트랜잭션 적용 등을 위한 그룹 멤버 간의 합의 처리도 담당 
      - 합의 처리 알고리즘: Paxos, Raft 등
        - Paxos: 분산 시스템에서 데이터 변경이 발생하는 서버가 여러 대 존재하는 경우 주로 사용
        - Raft: 데이터 변경이 한 대에서만 발생하는 경우 주로 사용
      - 그룹 통신 엔진은 Paxos 계열의 Mencius 알고리즘을 기반으로 구현됨 


- 그룹 복제를 구성하는 MySQL 서버의 수 
  - 복제 처리 시 합의 절차가 수행되므로, 정상 동작 하기 위해서는 과반수에 해당하는 서버가 정상 동작하고 있어야 함 
  - 적어도 세 대의 서버가 그룹에 존재해야 그룹 복제가 문제 없이 정상적으로 처리됨 
    - 한 대에 문제가 생겨도 그룹의 과반수에 해당하는 나머지 두 대의 서버에서 합의가 처리될 수 있어 그룹 복제가 계속 진행될 수 있기 때문
  - 서버 수 결정 공식 
    - `n = 2f + 1 (n: 전체 서버 수, f: 허용하고자 하는 장애 서버 수)`


## 17.2.2 그룹 복제 모드 
### 싱글 프라이머리 모드
![img_5.png](img/img_5.png)
- 그룹 내에서 쓰기를 처리할 수 있는 서버가 오직 한 대만 존재하는 형태 
- 프라이머리 서버가 변경되는 상황 
  - 자발적으로, 혹은 예기치 않게 프라이머리 서버가 그룹을 탈퇴하는 경우 
  - 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우 
- 프라이머리 서버 선출 기준  
  - MySQL 서버 버전 (최우선 고려)
    - 가장 낮은 MySQL 버전을 실행 중인 멤버를 확인함  
      - 모두 8.0.17 이상 → 패치 버전 기준 정렬
      - 8.0.17 미만 서버가 존재함 → 메이저 버전을 기준으로 정렬 
  - 각 멤버의 가중치 값 
    - 가장 낮은 버전을 가진 서버가 둘 이상 존재하는 경우, 시스템 변수에 지정된 가중치 값을 비교함 
  - UUID 값의 사전식 순서
    - 서버 버전과 가중치를 기준으로 선정된 멤버가 둘 이상 존재하는 경우, UUID 값의 사전식 순서를 바탕으로 가장 낮은 값을 가지는 멤버가 새로운 프라이머리로 최종 선택됨 

### 멀티 프라이머리 모드
![img_6.png](img/img_6.png)
- 그룹 내에서 멤버들이 전부 프라이머리로 동작하는 형태 
- 발생한 쓰기가 그룹의 다른 멤버들로 전파되어 각 멤버에서 다시 처리됨 
  - 그룹 멤버 간의 버전 호환성이 중요 
  - 모든 멤버가 동일한 MySQL 버전으로 실행되는 것이 좋음 
- 버전 호환성 검사를 수행함 
  - 새로운 멤버가 그룹 내 가장 낮은 버전보다 낮은 버전을 사용중인 경우 그룹에 참여 불가 
  - 새로운 멤버가 그룹 내 가장 낮은 버전과 동일한 버전을 사용중인 경우 그룹에 참여 가능 
  - 새로운 멤버가 그룹 내 가장 낮은 버전보다 높은 버전을 사용중인 경우 그룹에 참여는 가능하나, 읽기 전용 모드를 유지함 


## 17.2.3 그룹 멤버 관리(Group Membership)
- 그룹 멤버들에 대한 목록과 상태 정보를 관리 
  - 이를 "뷰(View)"라고도 함 


## 17.2.4 그룹 복제에서의 트랜잭션 처리
- 트랜잭션 적용을 위해 필요한 단계
  - 합의(Consensus)
  - 인증(Certification)

- 합의
  - 그룹 내 일관된 트랜잭션 적용을 위해 수행되는 과정 
  - 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정 (그룹 멤버 간 통신 결과를 바탕으로 처리)
  - 트랜잭션 커밋 요청 → 그룹 멤버가 그룹 통신 엔진을 통해 트랜잭션 데이터를 다른 멤버들에게 전파 → Paxos 기반 프로토콜을 바탕으로 합의 수행 → 최종 합의 완료 → 과반수 응답 메세지(ACK)를 전달받으면 다음 프로세스 진행 
    - 트랜잭션 데이터: WriteSet, 커밋될 당시의 스냅숏, 트랜잭션 이벤트 로그 데이터 등 
    - 과반수 응답을 받지 못한 경우 트랜잭션은 적용되지 않고 에러 반환 

- 인증
  - 전달받은 트랜잭션 WriteSet 데이터와 로컬의 WriteSet 히스토리 데이터를 비교 → 트랜잭션 충돌 여부 확인 (멀티 프라이머리 모드에서만 발생) 
    - 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백 
  - 인증 후 바이너리 로그에 트랜잭션을 기록하고 최종적으로 커밋을 완료
    - 클라이언트는 해당 시점에 커밋 요청에 대한 응답을 받게 됨
  - 트랜잭션을 전달받은 그룹의 다른 멤버들
    - 인증 → 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 이벤트 작성 → 어플라이어 스레드는 릴레이 로그에 기록된 트랜잭션을 실행 → 바이너리 로그에도 기록 → 트랜잭션 적용 

- 과정
  - ![img_7.png](img/img_7.png)

### 트랜잭션 일관성 수준 
- 그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용하나, **실제 적용 시점까지 완전히 일치하는 것은 아님** 
  - 한 멤버에서 쓰기 수행 → 다른 멤버에서 읽었을 때 최신 변경 사항이 반영되지 않았을 수 있음 
  - 프라이머리 장애로 인해 Failover가 발생해도 이러한 상황이 발생할 수 있음 
    - 새로 선출된 프라이머리가 이전 프라이머리에서 발생했던 트랜잭션을 적용하고 있는 상황에서 클라이언트가 새로운 프라이머리에 연결해 트랜잭션을 실행하는 경우 
    - 오래된 데이터를 읽거나 쓸 수 있음 
- 동기화는 빠르게 처리되므로 위와 같은 문제가 거의 발생하진 않으나, 짧은 순간에 일시적으로 발생할 위험이 있는 문제들임 
- MySQL 8.0.14 버전부터 문제 발생 방지 가능  
  - 그룹 복제에서 트랜잭션 일관성 수준을 설정할 수 있는 기능이 도입됨 

#### EVENTUAL 일관성 수준 
![img_8.png](img/img_8.png)
- 기본 설정값 
- 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게 됨을 의미 
- 읽기 전용 및 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능 
  - 트랜잭션이 직접 실행된 멤버가 아닐 경우, 일시적으로 변경 직전 상태가 읽혀질 수 있음
  - 프라이머리 Failover로 새로 선출된 프라이머리가 오래된 데이터를 읽거나, 쓰기 트랜잭션의 경우 충돌로 롤백될 수 있음 
  - 즉, 그림에서처럼 T1 트랜잭션이 완전히 적용되기 전에 T2가 실행될 수 있음


#### BEFORE_ON_PRIMARY_FAILOVER 일관성 수준
![img_9.png](img/img_9.png)
- 싱글 프라이머리 모드로 설정된 그룹 복제에서, 프라이머리 Failover가 발생해서 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향을 미치는 일관성 수준  
  - 선출된 신규 프라이머리가 BEFORE_ON_PRIMARY_FAILOVER 일관성 수준으로 설정돼 있고, 이전 트랜잭션을 적용하고 있는 경우
    - 새로 유입된 모든 트랜잭션은 이전 트랜잭션이 모두 적용될 때까지 처리하지 못하고 대기하게 된다
    - 즉, Failover로 프라이머리가 변경될 때, 이전 프라이머리의 트랜잭션이 모두 적용될 때 까지 신규 프라이머리는 새로운 트랜잭션을 처리하지 못함 
- 동기화가 잘 처리되고 있던 경우라면, 트랜잭션 간의 갭이 작아 문제가 되지 않을 것임 
  - 예상치 못한 변수로 트랜잭션 간의 갭이 크다면 응답 지연이 발생할 것임 (지연 대비 코드가 필요)
- 보장 수준
  - 신규 프라이머리로 유입된 모든 트랜잭션들은 최신 데이터를 바탕으로 동작함 
  - 신규 프라이머리로 유입된 읽기-쓰기 트랜잭션 간의 충돌로 인한 롤백은 발생하지 않음 
- 모든 새로운 읽기-쓰기 트랜잭션은 처리가 지연되나, 읽기 전용 트랜잭션에서 모든 종류의 읽기 쿼리들이 전부 지연되는 것은 아님 


#### BEFORE 일관성 수준 
![img_10.png](img/img_10.png)
- 모든 신규 트랜잭션은 모든 선행 트랜잭션이 완료될 때까지 대기 후 처리됨 
  - 선행 트랜잭션 = 해당 트랜잭션이 실행된 그룹 멤버에서의 선행 트랜잭션만을 의미함 (그림의 T1 트랜잭션)
- 보장 수준
  - 신규 트랜잭션은 항상 최신 데이터를 읽음 
  - 신규 트랜잭션은 선행 트랜잭션의 처리 시간에 영향을 받음 
- 반드시 최신 데이터를 읽어야 하며, DB에서 읽기 요청은 적고 쓰기 요청이 많은 경우에 사용하는 것이 좋음 


#### AFTER 일관성 수준
![img_11.png](img/img_11.png)
- 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 함  
  - 읽기-쓰기 트랜잭션은 다른 모든 멤버들에게도 해당 트랜잭션이 커밋될 준비가 됐을 때까지 대기한 후 처리됨
    - 그룹의 다른 멤버들로부터 응답을 받으면 최종적으로 커밋됨
    - 동시점에 실행되는 트랜잭션에 영향을 미침 (모든 멤버에 영향)
  - 읽기 트랜잭션은 별도의 제약 없이 바로 처리 
- 보장 수준
  - 후속 트랜잭션은 어떤 멤버에서는 일관된 최신 데이터를 얻을 수 있음 
- 모든 멤버를 대기해야 하므로 본래 처리 시간보다 더 많은 시간을 소요 
- 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 사용하고자 할 때 사용하면 좋음 


#### BEFORE_AND_AFTER 일관성 수준
![img_12.png](img/img_12.png)
- BEFORE와 AFTER가 결합된 형태 
- 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 기다린 후 실행 
  - 다른 모든 멤버들에게도 커밋이 준비되어 응답을 보내면 그 때 최종 커밋 
- 읽기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 대기한 후 실행 
- 보장 수준
  - 최신 데이터를 읽을 수 있음 
  - 읽기-쓰기 트랜잭션의 경우, 커밋되면 이후 모든 후속 트랜잭션은 최신 데이터를 읽게 됨 


### 흐름 제어(Flow Control)
- 일부 멤버가 하드웨어 스펙이 더 낮거나 네트워크 대역폭이 작은 경우, 또는 부하를 많이 받고있는 경우 트랜잭션 적용이 지연됨
  - 지연된 멤버에서 트랜잭션이 실행될 경우, 오래된 데이터를 읽을 가능성이 있음 + 충돌 위험 
  - 지연이 장시간 지속될 경우 트랜잭션 일관성 수준 조정으로는 해결할 수 없음 

- 흐름 제어(Flow control) 정의  
  - 그룹 멤버 간 트랜잭션 적용 불균형으로 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 메커니즘

- 특징 
  - 멤버 간 트랜잭션 갭을 적게 유지 → 멤버들의 데이터가 최대한 동기화된 상태로 유지될수 있게 함
  - 각 멤버들의 쓰기 처리량이 균등할 수 있게 함 
  - 필요 이상으로 처리량을 줄이지 않아 서버 자원이 불필요하게 유휴 상태에 놓이지 않게 함 

- 모드
  - QUOTA 
    - 기본 모드 
    - 그룹에서 쓰기를 처리하는 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식 
  - DISABLED
    - 흐름제어 비활성화 
    - 비활성화된 멤버는 다른 멤버들의 흐름 제어에 영향을 주지 않음 
      - 해당 멤버가 처리되지 않은 트랜잭션을 많이 가지고 있어도, 다른 멤버들의 쓰기 처리량이 조정되지 않음

- QUOTA 동작 방식 
  - 모든 그룹 멤버들의 쓰기 처리량 & 대기 중인 트랜잭션 통계 수집
    - 수집하는 정보 
      - 인증(Certification) 큐 크기 
        - 트랜잭션 충돌 감지 
      - 적용(Application) 큐 크기 
        - 트랜잭션을 반영 
      - 인증된 총 트랜잭션 수 
      - 적용된 원격 트랜잭션 수 
      - 로컬 트랜잭션 수 
  - 멤버 처리량을 조절할 필요가 있는지 확인 
    - 인증 큐 크기와 적용 큐 크기를 바탕으로 조절 필요성을 판단 
    - 얼마나 많은 트랜잭션이 대기하고 있는지를 확인 (설정값 이상의 트랜잭션이 대기중인 경우 흐름 제어 작동)
  - 조절이 필요한 경우, 수집된 통계 데이터를 바탕으로 할당할 쓰기 처리량을 계산 → 계산된 쓰기 처리량을 넘어선 쓰기를 처리하지 않도록 제한 
    - 트랜잭션 적용이 가장 뒤쳐진 멤버가 처리할 수 있는 수준으로 쓰기 처리량을 계산

- 흐름 제어는 각 멤버에서 개별적으로 수행됨 (동기화 형태 수행X)


## 17.2.5 그룹 복제의 자동 장애 감지 및 대응 
- 장애 감지 메커니즘 
  - 그룹 일부 멤버에 장애가 발생해 응답 불능 상태에 빠져도, 그룹이 정상 동작할 수 있게 하는 메커니즘 
  - 문제 상태의 멤버를 식별하여 그룹 복제에서 제외시킴 
- 장애 감지 방법
  - 멤버 간 주기적으로 통신 → 상태 확인 → 5초내로 메시지를 받지 못하면 문제가 생긴걸로 의심 → 과반수 멤버가 동의하면 해당 멤버를 그룹에서 추방 
  - 5초의 대기시간 동안 멤버는 `UNREACHABLE` 상태로 표시됨
- 멤버가 추방되면 그룹 뷰가 변경됨 → 새로운 뷰 ID 할당 
  - 멤버가 추방되었음을 알 수 있는 방법: 현재 뷰 ID가 그룹이 가진 뷰 ID랑 달라짐
    - 추방된 멤버는 다른 그룹 멤버들과 다시 통신이 되지 않으면 추방됐음을 알지 못함
    - 추방된 멤버는 자동 재가입 시도 가능  
- 소수에 속한 멤버들에서도 트랜잭션은 실행될 수 있다
  - 실행된 트랜잭션은 과반수 동의를 얻을 수 없어 보류된 상태로 남는다 
  - 시간이 초과될 경우, 멤버는 보류 상태의 모든 트랜잭션을 롤백하고 그룹에서 탈퇴함 


## 17.2.6 그룹 복제의 분산 복구 
- 분산 복구 
  - 그룹 가입 시 가입 멤버가 다른 그룹 멤버들과 동일한 최신 데이터를 가질 수 있도록 하는 복구 프로세스
    - 가입 멤버에서 누락된 트랜잭션들을 다른 그룹 멤버에서 가져와 적용
    - 동일한 데이터를 가져야 정상적인 상태로 참여가 가능하기 때문에 필요한 작업 

### 방식 
- 작업 시 가입 멤버에서 복제 채널의 릴레이 로그를 확인하여 미처 적용되지 못하고 남아있는 트랜잭션이 있는지 검토 
  - 가입 이력이 있는 경우, 그룹에서 탈퇴하는 시점에 적용되지 않은 트랜잭션이 존재할 수 있기 때문
    - 적용되지 못한 트랜잭션이 있는 경우, 이를 먼저 적용함 
- 로그 확인 후, 온라인 상태로 존재하는 다른 그룹 멤버에 연결하여 분산 복구 작업 진행
  - 바이너리 로그 복제 방식과 원격 클론(Remote Cloning) 방식 중 적합한 방식을 자동 선택 
  - 바이너리 로그 복제 방식 
    - 비동기 복제를 기반으로 구현 
    - 기증자 멤버의 바이너리 로그에서, 가입한 멤버에 적용되지 않은 트랜잭션을 복제해서 가져와 가입 멤버에 적용
    - 트랜잭션 갭이 크지 않거나 클론 플러그인이 없는 경우 사용하는 방식 
  - 원격 클론 방식 
    - 클론 플러그인 사용 
    - 다른 그룹 멤버의 InnoDB 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일관된 스냅숏으로 가져와 가입 멤버를 재구축
      - 기존 데이터는 모두 제거되어 스냅숏 데이터로 대체 
    - 트랜잭션 갭이 크거나, 트랜잭션 일부가 기존 멤버의 바이너리 로그에 존재하지 않는 경우 사용하는 방식

### 프로세스 
![img_13.png](img/img_13.png)
![img_14.png](img/img_14.png)
![img_15.png](img/img_15.png)

1. 로컬 복구
   - 가입 멤버가 가입 이력이 있는 경우, 릴레이 로그를 확인하여 적용하지 못한 트랜잭션을 확인 후 적용함 
   - 이후 본격적인 복구 진행 
2. 글로벌 복구
   - 가입 멤버가 기존 멤버 중에서 기증자 멤버를 선택 
   - 해당 멤버로부터 데이터 or 누락된 트랜잭션을 가져와 적용 
   - 작업 진행 중에는 해당 그룹에서 처리되는 트랜잭션이 내부적으로 캐싱됨
     - 바이너리 로그 복제 방식에서는 그룹에 참여한 시점까지만 복구 작업을 진행 → 복구 작업동안 그룹에서 처리되는 트랜잭션들을 캐싱하는 것 
3. 캐시 트랜잭션 적용
   - 글로벌 복구 단계 완료 후, 캐싱에서 보관한 트랜잭션들을 적용
   - 이후 최종적으로 그룹에 참여하게 됨 

### 설정 
- 설정할 수 있는 값들 
  - 연결 시도 횟수 
  - 연결 시도 간격
  - 가입한 멤버를 온라인(ONLINE) 상태로 표기하는 시점 

### 오류 처리 
- 장애 감지 메커니즘 
  - 복구 중 문제가 발생하더라도 다시 작업을 시도 
- 다음과 같은 경우 새로운 그룹 멤버로 연결을 전환하여 작업을 재시도함 
  - 기증자로 선택한 그룹 멤버로의 연결이 인증 문제 등으로 정상적으로 이뤄지지 않을 때 
  - 바이너리 로그 복제 방식으로 복구 작업을 진행하던 중, 레플리케이션 I/O 스레드 or SQL 스레드에서 에러가 발생했을 때 
  - 원격 클론 작업이 실패 or 완료 전에 중단됐을 때 
  - 복구 작업 동안 기증자 멤버에서 그룹 복제가 중단됐을 떄 
- 분산 복구 프로세스를 더이상 진행할 수 없는 경우
  - 지정된 재시도 횟수를 모두 소진했을 때 
  - 가입 멤버에 필요한 트랜잭션이 그룹 멤버들의 바이너리 로그에 존재하지 않고, 원격 클론 방식으로도 복구 작업을 진행할 수 없을 때 
  - 가입 멤버가 그룹에는 존재하지 않는 트랜잭션을 가지고 있는 상태에서 바이너리 로그 복제 방식으로 복구 작업이 진행될 때 
  - 가입 멤버가 원격 클론, 바이너리 로그 방식을 모두 실패하여 시도해볼 멤버가 존재하지 않을 때   
  - 진행 중 가입 멤버에서 그룹 복제가 중단됐을 때  


## 12.2.7 요구사항 
- InnoDB 스토리지 엔진 사용 
- PK 필수 사용 (혹은 Not null unique key)
- 원활한 네트워크 통신 환경 
- 바이너리 로그 활성화 
- ROW 형태 로그 포맷 사용 
- 바이너리 로그 체크섬 설정 
- `log_slave_updates` 활성화 
- `GTID` 사용 
- 고유한 `server_id`
- 복제 메타데이터 저장소 설정 
- 트랜잭션 `WriteSet` 설정 (변경 데이터에 대한 정보)
- 테이블 스페이스 암호화 설정 
- `lower_case_table_names` 통일 
- 멀티 스레드 복제 설정 (원본 서버의 커밋 순서와 동일한 순서로 커밋되도록)


## 12.2.8 제약 사항
- `GTID`에 따른 제약 사항이 기본적으로 따라옴 
- 갭락 
  - 갭락을 발생시킨 트랜잭션이 실행된 멤버에서만 유효함 
  - 트랜잭션 인증 단계에서 해당 락 정보는 공유되지 않음 
  - 멀티 프라이머리 모드에서는 `READ_COMMITED` 격리 수준을 사용해야 함 (갭락 발생X)
- 테이블 락, 네임드 락
  - 그룹 단위로 락 정보 공유 X 
  - 그룹 복제에서는 두 락을 고려하지 않음 
- 멀티 프라이머리 모드는 `SERIALIZABLE` 격리 수준을 사용할 수 없음
- 멀티 프라이머리 모드에서는 동일한 테이블에 대해 서로 다른 멤버에서 동시에 실행되는 DDL, DML은 지원하지 않음 
- 멀티 프라이머리 모드에서는 Foreign Key가 존재하는 테이블, 특히 CASCADE 제약 조건이 사용된 테이블은 지원하지 않음 
  - CASCADE: 계단식 데이터 변경 작업 유발 → 감지되지 않는 트랜잭션 충돌 발생 → 데이터가 일치하지 않을 수 있음 
- 멀티 프라이머리 모드에서 `SELECT ... FOR UPDATE` 구문은 데드락이 발생할 수 있음 
- 그룹 복제에서 복제 필터 기능 사용 불가 
- 최대 9대의 서버까지 구성 가능 


---

---

# 17.3 MySQL 셸 
- MySQL을 위한 고급 클라이언트 툴 
- SQL, js, python 모드 지원 
- API 제공 
  - X DevAPI
    - 관계형 데이터와 Document 기반 데이터를 모두 처리할 수 있게 함 
  - AdminAPI
    - MySQL 서버 설정 변경
    - InnoDB 클러스터 구성 
    - InnoDB 레플리카 셋 구축 

---

---

# 17.4 MySQL 라우터 
![img_16.png](img/img_16.png)
- Proxy 역할 수행 
  - 애플리케이션 서버로부터 유입된 쿼리 요청을 InnoDB 클러스터 내 적절한 MySQL 서버로 전달 
  - 반환된 쿼리 결과를 애플리케이션 서버로 전달
- 중요 기능
  - InnoDB 클러스터의 MySQL 구성 변경 자동 감지
    - MySQL 서버들에 대한 정보를 메모리에 캐시 → 주기적 갱신 
  - 쿼리의 부하 분산 
    - MySQL 라우터에서 클러스터로 설정된 라우팅 커넥션별로 수행됨 
  - 자동 Failover
    - 장애가 발생한 경우 자동으로 다른 서버로 쿼리 실행을 재시도 