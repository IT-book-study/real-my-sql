# Introduction
- 복제를 구성한다고 고가용성이 실현되는 것은 아님 
  - 소스 서버에 장애가 발생했을 때 레플리카 서버가 **자동으로 기존 소스 서버를 대체하는 것이 새로운 소스 서버로 전환되는 것이 아니**기 때문 
- MySQL은 서버 자체적으로 자동 페일오버(Failover)를 처리하는 기능을 제공하지 않음
  - 장애 발생 시, 사용자가 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 함 
- 일련의 작업
  - 레플리카 서버에 설정된 읽기 모드를 해제 
  - 스블릿 브레인(Split-Brain) 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 함 
    - 스플릿 브레인?
      - 클러스터로 구성된 두 시스템 간의 네트워크가 일시적으로 동시에 단절되거나 기타 시스템상의 이유로, 클러스터 상의 모든 노드들이 각자 자신이 Primary라고 인식하게 되는 상황 
      - 아마 MySQL 복제에서는 두 서버 모두 자신이 소스 서버라고 인식하는 상황을 말하는 것 같다. 
  - 애플리케이션 서버가 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 함 
- 장애 시간을 최소화 하는 것이 중요하다 
  - 자동화를 고려해야 함 
  - 서드파티 MA 솔루션: MMM, MHA, Orchestrator 
  - MySQL 5.7.17 부터는 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입됨 


---

---

# 17.1 InnoDB 클러스터 아키텍처 
![img.png](img.png)
- InnoDB 클러스터는 MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체임 
- 구성 요소
  - 그룹 복제(Group Replication)
    - 소스 서버 데이터를 레플리카 서버로 동기화 하는 기본적인 복제 역할 
    - 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리(그룹에 새로운 멤버 추가/제거) 역할 
    - Primary 서버: 읽기/쓰기 모두 가능 (소스 서버) 
      - 1~N대 존재 가능 
    - Secondary 서버: 읽기만 가능 (레플리카 서버)
    - 최소 3대 이상의 서버가 필요 
      - 3대로 구성했을 때 부터 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상 동작하기 때문 
  - MySQL 라우터(MySQL Router)
    - 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램 
    - 애플리케이션이 실행한 쿼리를 적절한 MySQL 서버로 전달하는 Proxy 역할
      - InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타 데이터 정보를 가지고 있음 
      - 애플리케이션의 커넥션 정보에는 MySQL 라우터 서버만 설정해두면 됨 
  - MySQL 셸(MySQL Shell)
    - 기본적인 SQL문 실행 
    - js, python 기반의 스크립트 작성 기능 
    - MySQL 서버에 대해 클러스터 구성 등의 Admin 작업을 할 수 있게 하는 AdminAPI 제공
      - 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있음 
      - 클러스터 상태 확인, 서버 설정 변경 등 여러 기능 제공 
- 장애가 발생한 경우
  - 그룹 복제가 먼저 이를 감지함 
    - 자동으로 해당 서버를 복제 그룹에서 제외 
  - MySQL 라우터가 복제 토폴로지 변경을 인지
    - 서버 관련 메타데이터를 갱신하여 애플리케이션 서버에서 실행된 쿼리가 정상 동작하는 MySQL 서버로만 전달되도록 함 


---

---

# 17.2 그룹 복제(Group Replication)
- 내부적으로 ROW 포맷 바이너리 로그와 릴레이 로그, GTID를 사용 

## 17.2.0 기존 복제와 그룹 복제의 차이
### 복제 방향  
![img_1.png](img_1.png)
- 기존 복제: 소스-레플리카 형태로 구성되어 단방향으로만 복제 
- 그룹 복제: 그룹 내 서버들은 서로 통신하며 양방향 복제 처리 가능 (쓰기 처리 서버 여러대 존재 가능)

### 복제 처리 방식 
![img_2.png](img_2.png)
- 기존 복제: 비동기, 반동기 방식으로 나뉨 
  - 소스 서버에서의 트랜잭션 커밋 처리가 레플리카 서버와 무관하게 처리됨
  - 소스 서버에서는 트랜잭션이 커밋될 경우, 레플리카 서버에도 해당 트랜잭션이 잘 적용됐는지 확인하지 않음 (반동기에서 전달 정도만 확인함)
  - 레플리카 서버로부터 응답을 받지 못했다고 해서 트랜잭션이 소스 서버에서 적용되지 않는 것은 아님 
    - 소스 서버에서 일방적으로 적용 
- 그룹 복제: 반동기 방식이라고 할 수 있으나, 기존 반동기 방식과는 차이가 있음 
  - 한 서버에서 트랜잭션 커밋 준비 완료 → 트랜잭션 정보를 그룹의 다른 멤버들에게 전송 → 과반수 이상의 멤버로부터 응답을 받음(consensus) → 트랜잭션을 인증(certify) → 커밋 처리 
    - 인증 과정: 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 "충돌 여부"를 검사하고, 문제 없이 적용 가능한지 그 여부를 확인함 
    - 과반 수 이상의 멤버로부터 응답을 받지 못할 경우, 해당 트랜잭션은 그룹에 적용되지 않음
  - 그룹 내 멤버들의 응답에 따라 트랜잭션 적용 여부가 결정됨
    - 합의(consensus) 과정 이라고 함 
    - 데이터를 변경하는 트랜잭션에 대해서만 이같은 합의 과정이 필요함 (읽기에는 필요 없음)
  - 트랜잭션을 실제로 적용했는지는 확인하지 않음


### 대표 기능 
- 그룹 멤버 관리
- 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지 
- 자동 Failover
- 자동 분산 복구 


## 17.2.1 그룹 복제 아키텍처 
![img_3.png](img_3.png)
- 그룹 복제 플러그인을 통해 서로간에 지속적으로 통신하며 복제 동기화를 처리 
- 복제 채널을 통해 그룹에서 실행된 모든 트랜잭션을 전달받아 적용하게 됨 
- 그룹에 새로 가입할 경우, 이미 참여중인 다른 서버들과 같이 최신 데이터를 가지도록 하는 그룹 복제 분산 복구 작업 가능

![img_4.png](img_4.png)
- 그룹 복제 플러그인의 구성 
  - Plugin API: 그룹 복제 플러그인이 MySQL 서버와 상호작용 하기위한 인터페이스 
    - MySQL 서버에서는 서버의 시작 또는 복구, 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달함 
    - 그룹 복제 플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 등을 서버에 전달함 
  - Replication Plugin: 그룹 복제 기능들이 실질적으로 구현돼 있는 계층 
    - 여러 모듈로 나눠져 있음 
    - API로 들어온 요청들은 각각 적절한 모듈로 전달됨 
    - 로컬 및 그룹 복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리됨 
    - 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파 등이 수행됨 
    - 그룹 복제의 분산 복구 작업도 해당 계층에서 처리 됨 
  - 그룹 통신 시스템 API & 그룹 통신 엔진
    - 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소 
    - 그룹 통신 엔진은 트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장함 
    - 그룹 복제 토폴로지 변경과 그룹 멤버의 장애 등을 감지 
    - 트랜잭션 적용 등을 위한 그룹 멤버 간의 합의 처리도 담당 
      - 합의 처리 알고리즘: Paxos, Raft 등
        - Paxos: 분산 시스템에서 데이터 변경이 발생하는 서버가 여러 대 존재하는 경우 주로 사용
        - Raft: 데이터 변경이 한 대에서만 발생하는 경우 주로 사용
      - 그룹 통신 엔진은 Paxos 계열의 Mencius 알고리즘을 기반으로 구현됨 


- 그룹 복제를 구성하는 MySQL 서버의 수 
  - 복제 처리 시 합의 절차가 수행되므로, 정상 동작 하기 위해서는 과반수에 해당하는 서버가 정상 동작하고 있어야 함 
  - 적어도 세 대의 서버가 그룹에 존재해야 그룹 복제가 문제 없이 정상적으로 처리됨 
    - 한 대에 문제가 생겨도 그룹의 과반수에 해당하는 나머지 두 대의 서버에서 합의가 처리될 수 있어 그룹 복제가 계속 진행될 수 있기 때문
  - 서버 수 결정 공식 
    - `n = 2f + 1 (n: 전체 서버 수, f: 허용하고자 하는 장애 서버 수)`