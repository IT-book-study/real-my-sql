# 16. 복제

- 복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.
- 원본 서버를 소스(Source)서버, 복제된 서버를 레플리카(Replica) 서버라고 한다.
- 복제 서버를 만드는 이유
    1. 스케일 아웃으로 트래픽 증가 대응
    2. 데이터 백업
    3. 데이버 분석용으로만 쓰는 복제 서버
    4. 데이터의 지리적 분산 이슈를 해결

## 16.2 복제 아키텍처

- Mysql 서버에서 발생하는 모든 변경사항은 바이너리 로그에 순서대로 기록된다.
- 아래와 같이 처리된다.
    1. 소스 서버가 바이너리 로그에 변경사항을 기록한다.
    2. 레플리카 서버로 바이너리 로그가 전송되고 레플리카 서버의 로컬 디스크(릴레이 로그)에 저장된다.
    3. 릴레이 로그에 있는 내용을 반영함으로서 소스 서버와 레플리카 서버의 동기화가 아루어진다.

## 16.3 복제 타입

- 복제는 소스 서버의 바이너리 로그에 기록된 변경 내역(이벤트)을 식별하는 방식에 따라 `로그 파일 위치 기반 복제`, `글로벌 트랜잭션 ID 기반 복제`로 나뉜다.

### 바이너리 로그 파일 위치 기반 복제

- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내의 위치(Offset)로 로그 이벤트를 식별해서 복제를 진행한다.
- 복제를 처음 구축할때 소스 서버의 어떤 로그 이벤트부터 시작할지 정해야 한다.
- 레플리카 서버는 소스로부터 어떤 이벤트를 가져왔고, 얼마나 적용했는지를 관리하며,  
    소스 서버에게 해당정보를 제공해 이후의 로그 이벤트를 가져온다.
- `바이너리 로그 파일 위치 기반 복제`에서는 로그 이벤트를 소스 서버의 바이너리 로그 파일명, 파일 내 위치 값의 조합으로 식별한다.
- 바이너리 로그에는 각 이벤트에 `server_id`라는 값도 저장되는데, 이는 해당 이벤트가 발생한 mysql 서버를 식별하기 위한 것이다.
    - 각 서버는 이 값이 자신 서버에 설정된 `server_id`와 같으면 해당 이벤트를 적용하지 않고 무시한다.
    - 이 값을 고유한 값으로 설정하지 않으면 이벤트가 **무시될** 수 있다.

#### 바이너리 로그 파일 위치 기반 복제 구축

- 이 예제는 한 대의 소스 서버에서 새로운 레플리카 서버를 구축하는 과정에 대해 살펴본다.

##### 설정 준비

- MySQL 8.0에는 바이너리 로그는 기본으로 설정되어 있고, `server_id`값도 기본 1로 설정된다.
    - 바이너리 파일은 데이터 리렉터리 밑에 "binlog"라는 이름으로 생성된다.
- log_bin 시스템 변수를 통해 바이너리 로그 파일 이름 / 위치 값을 설정할 수 있다.
    - **server_id는 고유한 값을 직접 지정해주는 게 낫다**
- `SHOW MASTER STATUS`라는 명령으로 바이너리 로그가 어떻게 기록되는지 알수 있다. 
    - 로그 파일명을 알 수 있고, 로그 이벤트가 얼마나 기록되었는지 알 수 있다.


- 레플리카 서버도 고유만 server_id만 지정해주자.
- relay_log 시스템 변수로 릴레이 로그 파일 위치 / 파일명을 설정할 수 있다.
- 릴레이 로그에 기록되는 이벤트는 레플리카 서버에 적용되면 필요 없어지므로 자동으로 삭제된다.
- 레플리카 서버를 읽기용으로만 쓴다면 `read_only` 설정을 하는 게 좋다.
- 레플리카 서버를 추후에 소스 서버로 승격될 수 있다면, `log_slave_updates` 시스템 변수를 명시하는 게 좋다.
    - 원래, 레플리카 서버는 복제에 의한 데이터 변경사항은 자신의 바이너리 로그에 기록하지 않는다.
    - `log_slave_updates` 시스템 변수는 복제에 의한 데이터 변경 내용도 자신의 바이너리에 기록하게 한다.

##### 복제 계정 준비

- 레플리카 서버는 DB 계정이 필요하다. -> 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야 하기 때문.
    - 이때 사용하는 계정을 복제용 계정이라고 한다.
    - 복제용 계정의 비밀번호는 레플리카 서버의 커넥션 메타데이터에 평문으로 저장된다. (복제용으로만 쓰자)
- 복제용 계정은 `REPLICATION SLAVE` 권한을 가지고 있어야 한다.
- ```sql
    CREATE USER 'repl_user'@'%' IDENTIFIED BY 'repl_user_password';
    GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
    ```
##### 데이터 복사

- 소스 서버에서 레플리카 서버로 데이터를 가져오기 위해선 MySQL엔터프라이즈 백업이나 `mysqldump`와 같은 툴을 이용한다.
    - 데이터가 크지 않으면 mysqldump를 많이 사용한다.
- mysqldump를 사용할때는 `--single-transaction`, `--master-data` 옵션을 사용해야 한다. 
    - `--single-transaction`는 하나의 트랜잭션만 사용하게 해서, 테이블이나 레코드에 잠금을 걸지 않고 데이터를 덤프받을 수 있다.
    - `--master-data`는 소스 서버의 바이너리 로그 파일명과 위치 정보를 포함하는 복제 설정 구문이 덤프 파일에 추가된다. (복제 연결을 위해서 반드시 필요하다)
    - `--master-data` 글로벌 락을 거는데, 이는 바이너리 로그를 순간적으로 고정시키기 위함이다.
- 데이터 덤프  
  ```sh
  linux> mysqldump -uroot -p --single-transaction --master-data=2 \
  --opt --routines --triggers --hex-blob --all-database > source_data.sql
  ```
- 데이터 적재  
  ```sql
  -- // MySQL 서버에 직접 접속해 데이터 적재 명령을 실행
  mysql> SOURCE source_data.sql
  ```

  ```sh
  ## MySQL 서버에 로그인 하지 않고 데이터 적재 명령을 실행
  ## 둘 중 하나
  linux> mysql -uroot -p < source_data.sql
  linux> cat source_data.sql | mysql -uroot -p
  ```

##### 복제 시작

- mysqldump를 해서 얻은 .sql파일에 보면 `CHANGE MASTER TO MASTER_LOG_FILE = ...`가 
- 다음과 같은 명령으로 복제 설정한다.  
  ```sql
  CHANGE REPLICATION SOURCE TO
    SOURCE_HOST= -- 소스 서버의 ip
    SOURCE_PORT= -- 소스 서버의 포트 번호
    SOURCE_USER= -- 복제용 계정 정보
    SOURCE_PASSWORD= -- 복제용 계정 정보
    SOURCE_LOG_FILE= -- 복제를 시작하고자 하는 바이너리 로그 파일명
    SOURCE_LOG_POS= -- 로그 내 위치값
    GET_SOURCE_PUBLIC_KEY=1; -- SSL 연결
  ```

### 글로벌 트랜잭션 아이디(GTID) 기반 복제

- 글로벌 트랜잭션 아이디는 전체 MySQL 서버들에서 고유한 글로벌 식별값을 제공해준다.

#### 바이너리 로그 파일 위치 기반 복제 방식의 문제

- 복제에서 각각의 이벤트들이 바이너리 로그 파일명과 파일 내 위치 값으로 식별되는게 바이너리 로그 파일이 저장되어 있는 소스 서버에서만 유효하다는 것이다?
- 레플리카 서버에도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없다?
- 장애복구에 문제가 있다!

[문제가 있는 시나리오]
- 레플리카 서버 B, C와 소스 서버 A가 있다고 하자.
- 아직 C는 A의 바이너리 로그를 다 받지 못한 상태다.
- ![Alt text](image.png)
- 이때, 소스서버인 A에 장애가 발생해서 서버가 종료됐다고 하자.
- 장애 대응으로 B서버를 소스서버로 승격했지만, C서버는 A 소스서버가 사라졌기 때문에 binary-log.000002파일도 없고 동기화가 불가능 하다.
- 동기화가 불가능하니, select 쿼리를 C서버가 담당할 수 없게 된다.
- ![Alt text](image-1.png)


[GTID를 사용한 시나리오]
- GTID는 바이너리 로그 파일을 특정하지 않기 때문에 다른 서버를 대상으로도 복제할 수 있다.
- 이번에도 같은 환경에서 GTID 방식으로만 바꾸었다.
- ![Alt text](image-2.png)
- 소스 서버에 장애가 발생해도 B서버에서 바이너리 로그 이벤트를 가져올 수 있다.
- ![Alt text](image-3.png)

#### 글로벌 트랜잭션 아이디

- GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자
- 트랜잭션이 발생한 서버에서, 복제 토폴로지 내 모든 서버에서 고유함
- 커밋되어 바이너리 로그에 기록된 트랜잭션에만 할당됨
    - select쿼리만 수행하는 트랜잭션은 할당되지 않는다.
- GTID는 `[소스 서버 아이디]:[트랜잭션 아이디 값]`로 구성되어 있다.
    - 소스 서버 아이디는 `server_uuid` 시스템 변수값을 사용하는데, 자동으로 부여되는 값이다.


~~무슨무슨 테이블 생략~~

#### 글로벌 트랜잭션 아이디 기반의 복제 구축

- 복제에 참여하는 모든 MySQL 서버들의 server_id를 고유하게 지정해줘야 한다.
    - 설정에 gtid_mode=ON과 enforce_gtid_consistency=ON를 명시해야 한다.
- GTID가 활성화된 소스 서버에서 mysqldump로 데이터를 덤프받아 레플리카 서버를 구축하려는 경우, 소스 서버 GTID 값을 레플리카 서버에서 gtid_purged 시스템 변수에 설정해야 한다.
    - gtid_purged: 현재 MySQL 서버의 바이너리 로그 파일에 존재하지 않는 모든 트랜잭션들의 GTID 셋
    - gtid_executed: MySQL 서버에서 실행되어 바이너리 로그 파일에 기록된 모든 트랜잭션들의 GTID 셋 (gtid_purged에 설정하면 자동으로 설정된다.)

##### 복제 시작

- 아래와 같이 복제를 시작할 수 있다.
- 주석처리된 옵션 대신 SOURCE_AUTO_POSITION이 들어간다.
- 레플리카 서버는 자신의 gtid_executed 값을 참조해 해당 시점부터 소스 서버와 동기화 하게된다.
  ```sql
  CHANGE REPLICATION SOURCE TO
    SOURCE_HOST= -- 소스 서버의 ip
    SOURCE_PORT= -- 소스 서버의 포트 번호
    SOURCE_USER= -- 복제용 계정 정보
    SOURCE_PASSWORD= -- 복제용 계정 정보
    SOURCE_AUTO_POSITION=1,
    -- SOURCE_LOG_FILE= 
    -- SOURCE_LOG_POS= 
    GET_SOURCE_PUBLIC_KEY=1; -- SSL 연결
  ```

#### 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기

- 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션을 무시하고 싶다면 레플리카 서버에서 수동으로 빈 트랜잭션을 생성해 GTID 값을 만들어야 한다.
    1. 복제를 중단한다.
    2. gtid_next 변수 값을 문제가 발생한 트랜잭션의 GTID로 설정한다.
    3. 아무것도 안하는 빈 트랜잭션을 생성한다.
    4. gtid_next 변수 값이 자동으로 초기화 될 수 있도록 설정한다.

#### Non-GTID에서 GTID로 온라인 변경

[사전 지식]
- enforce_gtid_consistency: 데이터 일관성을 해칠 수 있는 쿼리들이 실행되는 것을 허용할지를 제어하는 시스템 변수 -> ON으로 설정해야 한다. (허용하지 않음)
- gtid_mode: 트랜잭션을 어떻게 처리할지 정한다. (익명 트랜잭션은 바이너리 로그 파일명과 위치값으로 식별되는 것)
    - 순차적으로 변경할 수 있다. OFF -> OFF_PERMISSIVE -> ON_PERMISSIVE -> ON  

    |  | 신규 트랜잭션 | 복제된 트랜잭션
    ---------|----------|---------
    OFF | 익명 트랜잭션으로 기록됨 | 익명 트랜잭션만 처리 가능
    OFF_PERMISSIVE | 익명 트랜잭션으로 기록됨 | 익명 트랜잭션 및 GTID 모두 처리 가능
    ON_PERMISSIVE | GTID 트랜잭션으로 기록됨 | 익명 트랜잭션 및 GTID 모두 처리 가능
    ON | GTID 트랜잭션으로 기록됨 | GTID 트랜잭션만 처리 가능
    - 소스서버와 레플리카 서버간의 gtid_mode가 호환이 안될 수 있으니 유의 하자.

[GTID 방법]
1. 각 서버에서 enforce_gtid_consistency 값을 WARN로 변경
2. 각 서버에서 enforce_gtid_consistency 값을 ON으로 변경
3. 각 서버에서 gtid_mode 값을 OFF_PERMISSIVE로 변경
4. 각 서버에서 gtid_mode 값을 ON_PERMISSIVE로 변경
5. 잔여 익명 트랜잭션 확인 (익명 트랜잭션이 남아 있는지 확인)
6. 각 서버에서 gtid_mode 시스템 변수를 ON으로 변경
7. my.cnf 파일 변경 (gtid_mode=ON, enforce_gtid_consistency=ON)
8. GTID 기반 복제를 사용하도록 복제 설정을 변경

## 16.4 복제 데이터 포맷

### Statement 기반 바이너리 로그 포맷

- 변경 이벤트에 대해 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식
- 트랜잭션 수준이 반드시 "REPEATABLE-READ"이상이여야 함
- 장점: 로그 파일 용량이 작아진다, 복제도 더 빨라지고 보기도 좋다.
- 단점: 비확정적으로 처리될 수 있다. (소스 서버와 레플리카 서버 간의 일관성을 해칠 수 있다)
    - Row 포맷으로 복제될 때보다 데이터에 락을 더 많이 건다. (쿼리가 풀 테이블 스캔을 유발하거나 하는 경우)

### Row 기반 바이너리 로그 포맷

- 변경된 값 자체를 바이너리 로그에 기록하는 방식이다.
- 장점: 소스 서버와 레플리카 서버에 데이터 일관성을 보장할 수 있다. (UUID 같은 함수를 사용하더라도), 모든 트랜잭션 격리수준에서 사용가능하다.
- 단점: 바이너리 로그 파일 크기가 매우 커질 수 있다. 육안으로 확인하기 어렵다.

### Mixed 포맷

- 기본적으로는 Statement를 사용하고 데이터 일관성이 보장되지 않는 쿼리를 수행하면 자동으로 Row 포맷으로 전환한다.

### Row 포맷의 용량 최적화
Row 기반 바이너리 포맷을 사용할때 용량을 줄일 수 있는 방법들

#### binlog_row_image 수정하기

- binlog_row_image
    - full: 변경이 발생한 레코드의 모든 칼럼을 기록한다.
    - minimal: 필요한 것만 로그에 기록한다.
    - noblob: full과 같지만 BLOB이나 TEXT는 기록하지 않는다.


#### 바이너리 로그 트랜잭션 압축

- 바이너리 로그를 압축할 수 있다. 네트워크 트래픽도 아끼면서 용량 부담도 줄일 수 있다.
- 레플리카 서버로 로그를 전송할때도 압축된 형태로 보낸다.
- binlog_transaction_compression: 활성화 여부 (ON/OFF)
- binlog_transaction_compression_level_zstd: 압축 레벨 지정 (1~22 기본 3)
- 경우에 따라서 압축이 안되는 경우가 있다.
    - GTID 설정 이벤트
    - 데이터 불일치를 발생시킬 수 있는 이벤트
    - Statement 포맷의 이벤트

## 16.5 복제 동기화 방식

### 비동기 복제 (Asynchronous replication)

- 단점
    - 소스 서버는 변경 이벤트가 레플리카 서버에 잘 전달됐는지, 적용되었는지 알 수 없다.
    - 일부 트랜잭션이 누락될 수 있다.
- 장점
    - 트랜잭션 처리가 빠르다.
    - 레플리카 서버에 문제가 생겨도 소스 서버에 영향이 없다.

### 반동기 복제 (Semi-synchronous replication)

- 소스 서버가 레플리카 서버에 트랜잭션 로그가 잘 전달되었는지 알 수 있다.
- 하지만 적용 성공 여부는 알 수 없다. (그래서 반-동기)
- 소스 서버가 이벤트를 언제 보내는지에 따라 나뉜다.
    - AFTER_SYNC: 바이너리 로그 파일에 이벤트를 작성한 후 레플리카 서버에 전송한다.
    - AFTER_COMMIT: 변경사항이 커밋된 후 레플리카 서버에 전송한다.

## 16.6 복제 토폴로지

### 싱글 레플리카 복제 구성

- 하나의 소스 서버에 하나의 레플리카 서버만 연결한 형태
- 소스 서버: 읽기 + 쓰기 용도
- 레플리카 서버: 읽기 용도

### 멀티 레플리카 복제 구성

- 하나의 소스 서버에 여러개의 레플리카 서버를 연결한 형태
- 단순히 읽기 요청에 부하 분산을 위해 여러 서버가 필요할 수도 있고,
- 배치나 통계분석 등의 작업을 위해 용도를 특정 레플리카 서버를 사용할 수도 있다.

### 체인 복제 구성

- .. TODO;...
