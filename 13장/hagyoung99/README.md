# 13 파티션
- 논리적으로는 하나의 테이블, 물리적으로는 여러개의 테이블로 분리해 관리할 수 있게 해줌
- 대용량의 테이블을 소규모 테이블로 분산하는 목적

## 13.1 개요
### 13.1.1 파티션 사용 이유
- 하나의 테이블이 너무 커 인덱스 크기가 물리적 메모리보다 큰 경우, 데이터 특성상 주기적인 삭제 작업이 필요한 경우 사용
#### 13.1.1.1 단일 INSERT 와 단일 또는 범위 SELECT 의 빠른 처리
- update, delete 시에도 대상 레코드 검색을 위해 인덱스는 중요하다.
- 인덱스가 커질수록 select, update, delete 작업에 속도가 느려진다.
- 파티션은 데이터와 인덱스를 조각화해 물리적 메모리를 효율적으로 사용할 수 있게 해준다.
#### 13.1.1.2 데이터의 물리적인 저장소를 분리
- Mysql에서는 파티션 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가지는 형태는 지원하지 않는다.
#### 13.1.1.3 이력 데이터의 효율적인 관리
- 로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단히 처리가 가능하다.

### 13.1.2 MySQL 파티션의 내부 처리
```SQL
mysql> CREATE TABLE tb_article (
            article_id INT NOT NULL,
            reg_date DATETIME NOT NULL,
            ....
            PRIMARY KEY(article_id,  reg_date)
        ) PARTITION BY RANGE (YEAR(reg_date) ) (
            PARTITION p2009 VALUES LESS THAN (2010),
            PARTITION p2010 VALUES LESS THAN (2011),
            PARTITION p2011 VALUES LESS THAN (2012),
            PARTITION p9999 VALUES LESS THAN MAXVALUE
```
#### 13.1.2.1 파티션 테이블의 레코드 INSERT
- INSERT 쿼리가 실행되면
    - 파티션 키인 reg_date 값을 이용해 파티션 표현식을 평가
    - 평가된 결과로 레코드가 저장될 파티션 결정
    - 데이터 저장
#### 13.1.2.2 파티션 테이블의 UPDATE
- WHERE 조건에 파티션 키 칼럼이 존재한다면
    - 저장된 파티션에서 빠르게 대상 레코드 검색 후 데이터 변경
- WHERE 조건에 파티션 키 칼럼이 명시되지 않았다면
    - 테이블의 모든 파티션을 검색
- 파티션 키가 아닌 칼럼의 데이터 변경
    - 일반 테이블과 마찬가지로 칼럼 값만 변경
- 파티션 키를 변경할 경우
    - 기존 레코드가 저장된 파티션에서 해당 레코드 삭제
    - 업데이트할 파티션 키 칼럼의 표현식을 평가
    - 업데이트할 파티션 키에 대한 레코드를 새로 저장
#### 13.1.2.3 파티션 테이블의 검색
- 파티션 테이블 검색 시 성능에 영향을 미치는 조건
    - WHERE 조건으로 파티션 선택이 가능한가?
    - WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔) 할 수 있는가?
- 위의 조건의 조합 실행
    1. 파티션 선택 가능 + 인덱스 효율적 사용 가능
        - 가장 효율적으로 처리 가능
        - 파티션의 개수와 관계 없이 검색을 위해 필요한 파티션의 인덱스만 레인지 스캔
    2. 파티션 선택 불가 + 인덱스 효율적 사용 가능
        - 테이블의 모든 파티션을 대상으로 인덱스 레인지 스캔을 수행해 검색
        - 파티션 개수만큼 인덱스 레인지 스캔 후 결과를 병합해 가져오는 것과 동일
    3. 파티션 선택 가능 + 인덱스 효율적 사용 불가
        - 파티션 개수와 관계 없이 필요한 파티션만 읽을 수 있음
        - 인덱스를 사용하지 못해 대상 파티션에 대해 풀 테이블 스캔을 진행
    4. 파티션 선택 불가 + 인덱스 효율적 사용 불가
        - 모든 파티션에 대해 풀 테이블 스캔을 진행
- 3, 4번의 방식은 가능하다면 피하는게 좋다. 2번의 방식도 파티션의 개수가 많을 경우 주의가 필요하다.
#### 13.1.2.4 파티션 테이블의 인덱스 스캔과 정렬
- 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당되어 파티션 단위로 생성되며 테이블 전체 단위로 글로벌하게 지원하지는 않는다.
- 여러 파티션에 대해 인덱스 스캔 수행 과정
    - 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서로 조회
    - 조회된 값을 우선순위 큐에 임시로 저장
    - 우선순위 큐에서 다시 필요한 순서대로 데이터 조회 후 반환
- MySQL 서버는 파티션 테이블 조회 시 별도의 정렬 작업을 하지 않지만 내부적으로 큐처리를 진행한다.
#### 13.1.2.5 파티션 프루닝
- 최적화 단계에서 필요한 파티션만 골라내는 것을 `파티션 프루닝` 이라고 한다.
- 실행 계획 시 어떤 파티션에 접근하는지 알 수 있다.
    - EXPLAIN 명령어의 partitions 칼럼을 확인

## 13.2 주의 사항
### 12.2.1 파티션의 제약 사항
```SQL
mysql> CREATE TABLE tb_article (
            article_id INT NOT NULL AUTO_INCREMENT,
            reg_date DATETIME NOT NULL,
            ....
            PRIMARY KEY(article_id,  reg_date)
        ) PARTITION BY RANGE (YEAR(reg_date) ) (
            PARTITION p2009 VALUES LESS THAN (2010),
            PARTITION p2010 VALUES LESS THAN (2011),
            PARTITION p2011 VALUES LESS THAN (2012),
            PARTITION p9999 VALUES LESS THAN MAXVALUE
```
- 제약사항
    - 스토어드 루틴이나 UDF, 사용자 변수 등을 파티션 표현식에 사용 불가능
    - 파티션 표현식은 칼럼 자체 또는 내장함수 사용 가능한데 일부 함수는 파티션 프루닝 미지원
    - 프라이머리 키를 포함해 테이블의 모든 유니크 인덱스는 파티션 키 컬럼을 포함해야함
    - 파티션된 테이블의 인덱스는 모두 로컬 인덱스, 동일 테이블의 인덱스는 같은 구조여야하고 개별로 사용 불가능
    - 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진을 가짐
    - 최대 8192개의 파티션을 가질 수 있음
    - 파티션 생성 이후 sql_mode 시스템 변수 변경은 데이터 파티션의 일관성을 깨뜨릴 수 있음
    - 파티션 테이블에서는 외래키 사용 불가능
    - 공간 데이터 저장 타입은 파티션 사용 불가능
    - 임시 테이블은 파티션 기능 사용 불가능

### 13.2.2 파티션 사용 시 주의사항
#### 13.2.2.1 파티션과 유니크 키(프라이머리 키 포함)
- 종류와 관계 없이 테이블에 유니크 인덱스가 있으면 파티션 키는 유니크 인덱스의 일부나 모든 칼럼을 포함해야한다.
- 유니크 키로 해당 데이터가 있는 파티션을 찾을 수 있다면 설정이 잘된 것
#### 13.2.2.2 파티션과 open_files_limit 시스템 변수 설정
- 일반 테이블은 동시에 오픈된 파일의 개수가 테이블 1개당 2개에서 3개지만 파티션은 파티션의 개수만큼 더 생기기 때문에 파일의 개수 설정을 해주는게 좋다.

## 13.3 MySQL 파티션의 종류
### 13.3.1 레인지 파티션
- 파티션 키의 연속된 범위로 파티션을 정의 하는 방법
- MAXVALUE 라는 키워드를 이용해 명시되지 않은 범위의 파티션 정의가 가능하다.
#### 13.3.1.1 레인지 파티션의 용도
- 아래의 경우 레인지 파티션을 사용하는게 좋다.
    - 날짜 기반의 데이터가 누적되고, 연도, 월, 일 단위로 분석하고 삭제해야할 때
    - 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
    - 파티션 키 위주로 검색이 자주 실행될 때
- 파티션의 장점
    - 큰 테이블을 작은 크기의 파티션으로 분리
    - 필요한 파티션만 접근(쓰기와 읽기 모두)
- 두번째 장점의 효과가 매우 크다
#### 13.3.1.2 레인지 파티션 테이블 생성
- `PARTITION BY RANGE` 키워드로 레인지 파티션 정의
- `PARTITION BY RANGE` 뒤에 칼럼이나 내장함수를 이용해 파티션 키 명시
- `VALUES LESS THAN` 으로 명시된 값보다 작은 값만 해당 파티션에 저장하게 설정
- `VALUES LESS THAN MAXVALUE` 로 명시되지 않은 레코드 저장할 파티션 지정
#### 13.3.1.3 레인지 파티션의 분리와 병합
- 단순 파티션 추가 : `ALTER TABLE` 로 파티션 추가
    - `ALTER TABLE ... REOGRANIZE PARTITION` 명령으로 MAXVALUE 파티션이 있는 테이블에 파티션 추가를 할 수 있다.
    - `MAXVALUE` 파티션 추가는 INSERT 되는 데이터의 특성이나 배치 스크립트의 안정성에 따라 적절히 판단
    - 파티션 삭제
        - `DROP PARTITION` 키워드로 파티션 삭제 가능
        - 단 가장 오래된 파티션부터 삭제가 가능하다
    - 기존 파티션의 분리
        - `REORGANIZE PARTIION` 명령을 사용
        - 파티션 키에 의해 데이터까지 재배치 돼서 레코드가 많다면 ALGORITHM, LOCK 절을 사용해 온라인 DDL 로 실행
    - 기존 파티션의 병합
        - `REORGANIZE PARTIION` 명령을 사용
        - 파티션의 재구성이 필요해 읽기 잠금을 필요로 한다.
### 13.3.2 리스트 파티션
- 레인지 파티션과 거의 비슷하지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열한다.
- MAXVALUE 파티션을 정의할 수 없다.
#### 13.3.2.1 리스트 파티션의 용도
- 파티션의 키 값이 코드 값이나 카테고리와 같이 고정적인 경우
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때
#### 13.3.2.2 리스트 파티션 테이블 생성
- `PARTITION BY LIST` 키워드로 생성할 파티션이 리스트 파티션임을 명시
- `PARTITION BY LIST` 키워드 뒤에 파티션 키를 정의
- 정수 타입의 파티션 키 뿐만이 아닌 문자열 타입일 때도 사용이 가능
#### 13.3.2.3 리스트 파티션의 분리와 병합
- 레인지 파티션의 추가 및 삭제, 병합 작업이 모두 같다
#### 13.3.2.4 리스트 파티션 주의사항
- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파이션 정의 불가능
- 레인지 파티션과는 다르게 NULL을 저장하는 파티션 별도 생성 가능
### 13.3.3 해시 파티션
- MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
- 파티션의 표현식의 결과 값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정한다.
- 파티션 키는 정수타입의 컬럼 또는 정수를 반환하는 표현식만 가능
- 레코드의 수가 파티션의 개수에 맞춰 할당되기 때문에 파티션 추가 삭제 시 테이블 전체적으로 재분배 필요
#### 13.3.3.1 해시 파티션의 용도
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는게 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커 파티션을 적용해야 할 때
- 테이블의 데이터가 특정 칼럼 값에 영향받지 않고, 전체적으로 비슷한 사용빈도를 보일 때 적합
#### 13.3.3.2 해시 파티션 테이블 생성
- `PARTITION BY HASH` 키워드로 파티션 종류가 해시 파티션임을 명시
- `PARTITION BY HASH` 키워드 뒤에 파티션 키 명시
- 해시 파티션의 파티션 키 또는 파티션 표현식은 반드시 정수 타입의 값을 반환해야함
- `PARTITIONS n` 으로 몇개의 파티션을 생성할지 명시
#### 13.3.3.3 해시 파티션의 분리와 병합
- 해시 파티션은 분리 또는 병합 시 재분배가 필수
- 해시 파티션 추가
    - 새로운 파티션 추가 시 개수가 분산되기 때문에 모든 레코드가 재배치 되어야한다.
    - 레코드 리빌드 작업시 테이블에 대한 읽기 잠금이 필요하고 데이터에 따라 많은 부하를 발생시킨다.
- 해시 파티션 삭제
    - 파티션 단위로 레코드 삭제하는 방법은 없다.
- 해시 파티션 분할
    - 파티션 추가만 가능하고 분할하는 기능은 없다.
- 해시 파티션 병합
    - 통합하는 기능은 미제공, 파티션의 개수를 줄이는 것만 가능하다.
        - `COALESCE PARTITION` 명령어 사용

### 13.3.4 키 파티션
- 해시 파티션과 사용법 및 특성이 거의 같음
- 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시
- 선정된 파티션 키의 값을 MD5() 함수를 이용해 해시값 계산 후 MOD 연산으로 데이터를 분배한다.
#### 13.3.4.1 키 파티션의 생성
- `PARTITION BY KEY` 키워드로 파티션 정의
    - 프라이머리 키 존재 시 자동으로 프라이머리 키가 파티션 키로 사용
    - 프라이머리 키가 없는 경우 유니크 키가 파티션 키로 사용
    - 프라이머리 키, 유니크 키 미존재 시 컬럼 일부를 파티션키로 명시적 설정

### 13.3.5 리니어 해시 파티션/리니어 키 파티션
- 리니어 해시 파티션/리니어 키 파티션은 각 레코드 분배를 위해 `Power-of-two(2의 승수)`알고리즘을 이용한다.
- 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화한다.
- 파티션의 추가 및 통합
    - `Power-of-two` 분배 방식 사용으로 특정 파티션의 데이터에 대해서만 이동 작업을 하면 됨
- 파티션과 관련된 주의사항
    - 범위를 최소화하는 대신 각 파티션이 가지는 레코드의 건수가 덜 균등해질 수 있음
    - 추가, 삭제 할 요건이 많다면 리니어해시/리니어키 파티션 적용이 좋고, 파티션 조정할 필요가 없다면 일반 해시/키 파티션 사용이 좋다.

### 13.3.6 파티션 테이블의 쿼리 성능
- 쿼리 성능은 테이블에서 얼마나 많은 파티션을 프루닝 할 수 있는지가 관건
- 파티션 사용 시에는 반드시 파티션 프루닝이 얼마나 도움이 될지 예측 후 응용 프로그램에 적용하는게 좋다.
- 레인지 파티션 이외에는 더더욱 고민해야한다.