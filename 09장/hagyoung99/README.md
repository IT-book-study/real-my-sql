# 09장 옵티마이저와 힌트 
- 요청된 쿼리는 결과는 동일하지만 결과를 만들어내는 방법이 매우 다양하다.
- 어떤 방법으로 최적의 실행 계획을 수립할지 정하는 기능을 **옵티마이저** 가 담당한다.
- 이때 `EXPLAIN` 라는 명령으로 쿼리의 실행 계획을 확인할 수 있다.

## 9.1 개요
### 9.1.1 쿼리 실행 절차
1. 요청된 SQL 문장을 잘개 쪼개 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
    - 이 단계를 **SQL 파싱**이라 하며 SQL 서버의 **SQL 파서** 모듈로 처리한다.
    - 문법적으로 잘못된 부분이 걸러지며 처리되면 ** SQL 파스 트리**가 만들어지고, 파스트리를 이용해 쿼리를 실행한다.
2. 파싱 정보(파스 트리)를 확인, 어떤 테이블과 인덱스를 이용해 테이블을 읽을지 선택한다.
    - 이 단계를 **최적화 및 실행 계획 수립** 단계라 하며 MySQL 서버의 **옵티마이저**에서 처리한다.
    - 이 단계가 완료되면 쿼리의 **실행 계획**이 만들어진다.
3. 결정된 테이블의 읽기 순서나 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
   - 수립된 실행 계획대로 스토리지 엔진으로부터 레코드를 읽어오고, 받은 레코드를 조인하거나 정렬한다.
- 1, 2 단계는 거의 MySQL 엔진에서 처리하고, 세번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해 처리한다.

### 9.1.2 옵티마이저의 종류

- 규칙 기반 최적화 방법(Rule-based optimizer, PRO)
   - 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 선순위에 따라 실행계획을 수립한다.
   - 테이블의 레코드 건수나 컬럼값의 분포도를 조사하지 않기 때문에 같은 쿼리에 대해서 같은 실행방법을 만들어낸다.
   - 사용자의 데이터 분포가 다양하기 때문에 대부분의 DBMS 에서는 사용되지 않는다.
- 비용 기반 최적화 방법(Cost-based optimizer, CBO)
   - 쿼리 처리를 위한 여러 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
   - 산출된 방법 중 비용이 가장 적은 처리방식을 선택해 최종적으로 쿼리를 실행한다.
   - 대부분의 RDBMS 가 선택하고 있는 방식이다.

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔은 인덱스 사용 없이 테이블의 데이터를 처음부터 끝까지 읽어 요청을 처리하는 작업으로 테이블의 레코드 건수가 너무 작거나 인덱스를 이용할 수 있는 적절한 조건이 없거나 옵티마이저 판단으로 조건에 해당하는 레코드 건수가 너무 많은 경우 실행된다.
- 대부분의 DBMS 는 풀 테이블 스캔 시 한꺼번에 여러개의 블록이나 테이블을 읽어오는 기능을 가지고 있지만 MySQL의 InnoDB의 경우 다른 방식으로 테이블을 읽어온다.
- MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 사용해 포그라운드에서 설정된 수만큼의 데이터 페이지가 읽히면 백스라운드 스레드를 이용해 대량으로 다음 페이지를 읽어 버퍼풀에 적재하고, 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져와 사용해 쿼리가 빠르게 처리된다.
   - 백그라운드의 앞으로 필요할 데이터를 미리 예측해 디스크에서 읽어 InnoDB 의 버퍼 풀에 가져다 놓는 작업을 **리드 어헤드**라고 한다.
- 리드 어헤드는 풀 테이블 스캔에서 뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.
- 풀 인덱스 스캔은 레코드 내 상세 컬럼 값이 아닌 단순 레코드의 건수만 필요로 하는 쿼리에 주로 사용되며 테이블 자체보다는 용량이 적어 훨씬 빠른 처리가 가능하다.

### 9.2.2 병렬처리

- 병렬처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것을 의미한다.
- `innodb_parallel_read_threads` 시스템 변수를 사용해 최대 몇개의 스레드를 이용해 처리할 지 설정할 수 있다.
- MySQL 8.0버전부터 사용이 가능하며 where 조건 없이 전체 건수를 가져오는 쿼리만 병렬로 처리가 가능하다.
- 병렬 처리용 스레드의 개수가 늘수록 처리시간은 줄어들지만 서버에 장착된 CPU 코어수를 넘을 경우 성능이 떨어질 수 있으니 주의가 필요하다.

### 9.2.3 ORDER BY 처리(User filesort)

- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 `filesort` 라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
   - 인덱스 이용
      - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 순서대로 읽기만 해 속도가 빠르다.
      - INSER, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요해 느리다.
      - 인덱스 때문에 디스크 공간이 더 필요하고, 인덱스 개수가 늘어날 수록 InnoDB 버퍼 풀을 위한 메모리가 더 필요하다.
   - Filesort 이용
      - 인덱스를 생성하지 않아 엔덱스의 단점이 장점이 된다.
      - 정렬할 레코드가 많지 않으면 메모리에서 처리되어 빠르다.
      - 정렬작업이 쿼리 실행 시 처리되어 레코드 대상 건수가 많아질수록 응답이 느리다.
- #### 인덱스를 이용하지 못하는 경우
   - 정렬 기준이 너무 많아 요건별로 모두 인덱스 생성이 불가능한 경우
   - GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야하는 경우
   - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
   - 랜덤하게 결과 레코드를 가져와야 하는 경우
- filesort 사용 여부는 실행 계획의 Extra 칼럼에 `Using filesort` 메시지가 표시되는지로 확인할 수 있다.

#### 9.2.3.1 소트 버퍼

- 정렬 수행을 위해 별도의 메모리 공간을 할당받는데 이 공간을 **소트 버퍼**라고 한다.
- 정렬이 필요한 경우에만 할당되며 크기는 레코드 크기에 따라 가변적으로 변하지만 최대 사용한 공간은 `sort_buffer_size`로 지정할 수 있다.
- 해당 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

> 메모리의 정렬 과정
>- 메모리의 소트버퍼에서 정렬을 수행하고 디스크에 임시로 기록
>- 다음 레코드를 가져와 정렬 후 디스크에 기록 하는 과정을 반복
>- 정렬된 레코드를 다시 병합하면서 정렬을 수행

- 위의 과정으로 데이터를 정렬하는데 이때 디스크의 쓰기와 읽기가 발생해 레코드의 건수가 많을수록 이 반복 작업의 횟수도 많아져 소트 버퍼의 크기가 크면 성능이 좋아질거라 생각할 수 있지만 소트 버퍼의 메모리 영역은 세션 메모리 영역으로 정렬 작업이 많으면 소트버퍼로 소비되는 메모리 공간이 커져 오히려 문제를 발생할 수 있다.
- 소트 버퍼의 크기를 크게 설정해 디스크의 읽기와 쓰기 사용량은 줄일 수 있기 때문에 디스크의 I/O 성능이 낮은 장비의 경우 크게 설정하는 것이 도움이 도니다.

#### 9.2.3.2 정렬 알고리즘

- 레코드 정렬 시 레코드 전체를 소트 버퍼에 담는 경우 **싱글 패스** 라고 하며 아래의 방식으로 정렬한다.
   - <sort_key, additional_fiields>: 정렬 키와 레코드 전체를 가져와 정렬하는 방식, 레코드의 칼럼을 고정 사이즈 메모리로 저장
   - <wort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와 정렬하는 방식, 레코드의 칼럼들은 가변 사이즈로 메모리에 저장
- 정렬 기준 칼럼만 소트 버퍼에 담는 경우 **투 패스** 라고 하며 아래의 방식으로 정렬한다.
   - <sort_key, rowId> : 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식

   #### 9.2.3.2.1 싱글 패스 정렬 방식    

  - 소트 버퍼에 정렬 기준 칼럼을 포함해 select 대상이 되는 칼럼 전부를 담아 정렬을 수행
  - 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 전달한다.
  - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보인다.

   #### 9.2.3.2.2 투 패스 정렬 방식

  - 정렬 대상 칼럼과 프라이머리 키 값만으로 소트 버퍼에 담아 정렬을 수행
  - 정렬된 순서대로 프라이머리 키를 이용해 테이블을 한번 더 읽어 요청에 맞는 데이터를 클라이언트로 전달한다.
  - 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적이다.

- 투 패스 방식은 테이블을 두번 읽어야하지만 필요로 하는 소트버퍼 공간이 적고, 싱글 패스 방식은 테이블을 한번만 읽지만 소트버퍼 공간이 더 많이 필요해 레코드의 크기에 의존적이게 된다.
- 최신 버전에서는 일반적으로 싱글 패스 방식을 주로 사용하며 레코드의 크기가 시스템 변수에 설정된 값보다 크거나 BLOB나 TEXT 타입의 칼럼이 조회 대상에 포함될 땐 투 패스 방식을 사용한다.

#### 9.2.3.3 정렬 처리 방법
- 인덱스를 사용한 정렬, 조인에서 드라이빙 테이블만 사용한 정렬, 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 하는 세가지 방법으로 정렬을 처리하며 뒤로 갈수록 처리 속도는 떨어진다.

   #### 9.2.3.3.1 인덱스를 이용한 정렬
   - 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 인덱스가 있어야한다.
   - 첫번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은인덱스를 사용할 수 있어야한다.
   - B-Tree 계열이 아닌 인덱스와 R-Tree 의 경우 사용할 수 없고, 여러 테이블이 조인 되는 경우 네스티드-루프 방식의 조인에서만 사용할 수 있다.
   - 실제 인덱스가 정렬되어있기 때문에 인덱스의 순서대로 읽으면 된다. 이때 조인 버퍼가 사용되면 순서가 흐트러질 수 있어 주의해야한다.

   #### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
  - 조인을 실행하기 전 첫 번째 테이블의 레코드를 먼저 정렬 한 후 조인을 실행한다.
  - 첫 번째로 읽히는 테이블의 칼럼만으로 ORDER BY 절을 작성해야한다.

   #### 9.2.3.3.3 임시 테이블을 이용한 정렬
  - 조인의 결과를 임시 테이블에 저장하고 그 결과를 다시 정렬하는 과정으로 실행된다.
  - 2개 이상의 테이블을 조인해 정렬해야할 때나 ORDER BY 절의 정렬 기준 칼럼이 드라이빙 테이블이 아닌 드리븐 테이블일 때 사용된다.

   #### 9.2.3.3.4 정렬 처리 방법의 성능 비교
  - LIMIT을 이용해 건수를 제안해 데이터를 가져오는 경우 **스트리밍 처리** 와 **버퍼링 처리**로 구분할 수 있다.
  
      #### 9.2.3.3.4.1 스트리밍 처리 방식
    - 서버 쪽에서 처리할 데이터 양에 관계 없이 조건에 일치하는 레코드가 검색되면 바로 클라이언트로 전송하는 방식이다.
      - 요청하고 곧바로 첫번째 레코드를 전달받지만 마지막 레코드는 언제 받을지 알 수 없다.
    - 레코드를 찾는 즉시 전달받기 때문에 동시에 가공 작업을 시작할 수 있어 LIMIT 같은 결과 건수를 제한하는 조건은 쿼리 실행 속도를 줄여줄 수 있다.

      #### 9.2.3.3.4.2 버퍼링 방식
    - ORDER BY 나 GROUP BY는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 해 버퍼링 방식을 사용한다.
    - wehre 조건에 일치하는 모든 레코드를 가져온 후 정렬하거나 그루핑해 차례대로 클라이언트로 보낸다.
    - 모든 레코드가 검색되고 정렬되는 동안 클라이언트는 기다려야하기 때문에 응답속도가 느려지며 모든 레코드에 가공이 들어간 후 건수가 제한되기 때문에 LIMIT은 도움이 되지 않는다.
- 인덱스를 사용한 정렬 방식만 스트리밍 처리 방식으로 처리되며 나머지는 버퍼링 방식으로 처리된다.

#### 9.2.3.4 정렬 관련 상태 변수
- 주요 작업에서는 해당 작업의 실행 횟수를 상태 변수로 저장해 명령을 통해 작업 횟수를 확인할 수 있다.


### 9.2.4 GROUP BY 처리
- 쿼리가 스트리밍 처리를 할 수 없게 하는 처리

#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼이 인덱스가 있다면 차례로 읽어 그루핑하고, 그 결과로 조인을 처리한다.
#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너 뛰면서 필요한 부분만 읽어 가져오는 것을 의미
- 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다.
- 루스 인덱스 스캔으로 처리되는 쿼리는 임시 테이블이 필요하지 않다.
#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
- GROUP BY의 기준 칼럼이 드라이빙, 드리븐 테이블에 관계 없이 인덱스를 전혀 사용하지 못할때 처리된다.

### 9.2.5 DISTINCT 처리

### 9.2.6 내부 임시 테이블 활용
