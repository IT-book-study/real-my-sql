# 9.1 개요 
- 실행 계획을 이해할 수 있어야 함
  - 실행 계획의 불합리한 부분을 찾아내어 최적화된 방법을 사용하도록 유도할 수 있음 

## 9.1.1 쿼리 실행 절차 
1. 사용자가 SQL 문장 요청
2. 요청된 SQL 문장을 파싱하여 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
   - SQL 파서라는 모듈이 처리 
   - 문법이 잘못된 경우를 걸러냄 
   - 파스 트리 생성
3. SQL의 파싱 정보인 파스 트리를 확인하면서 어떤 테이블부터 읽고, 어떤 인덱스를 이용할지 선택하여 데이터를 읽어옴
   - 최적화 및 실행 계획 수립 단계 (옵티마이저)
     - 불필요한 조건 제거 
     - 복잡한 연산 단순화 
     - 테이블 조인이 있는 경우, 어떤 순서로 테이블을 읽을 것인지 결정 
     - 각 테이블에 사용된 조건과 인덱스 통계 정보를 토대로 사용할 인덱스 결정 
     - 가져온 레코드들을 임시 테이블에 넣고, 다시 한번 가공해야 하는지 그 여부를 결정 

## 9.1.2 옵티마이저의 종류
### 규칙 기반 최적화(Rule-based Optimizer, RBO)
- 같은 쿼리에 대해 항상 같은 실행 방법
  - 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
  - 대상 테이블의 레코드 건수나 선택도 고려 X 
  - 통계 정보(테이블 레코드 건수, 컬럼값 분포도) 조사 X
- 사용자 데이터는 분포도가 다양하여 이를 고려해야 하기 때문에 거의 사용되지 않는 방식임  

### 비용 기반 최적화(Cost-based Optimizer, CBO)
- 쿼리를 처리하기 위해 여러 가지 가능한 실행 계획을 만듦 
  - 각 단위 작업의 비용(부하) 정보 + 대상 테이블의 예측된 통계 정보 → 실행 계획별 비용 산출 
  - 비용이 최소로 소요되는 처리 방식 선택 
- 대부분의 RDBMS가 사용하는 방식


---

---

# 9.2 기본 데이터 처리 
## 9.2.1 풀 테이블 스캔 & 풀 인덱스 스캔 
### 풀 테이블 스캔(Full Table Scan)
- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어오는 방식
- MySQL 옵티마이저는 아래의 조건이 일치할 때 주로 풀 테이블 스캔 선택 
  - 테이블의 레코드 건수가 적을 때
    - 일반적으로 테이블이 페이지 1개로 구성된 경우 
    - 레코드 건수가 적을 때는 풀 테이블 스캔이 빠르다 
  - `where`, `on` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우 
  - 인덱스 레인지 스캔을 사용할 수 있더라도, 조건 일치 레코드가 너무 많은 경우 
    - ex: 테이블의 절반 이상이 조건에 일치하는 경우
- 리드 어헤드(Read ahead)
  - 특정 테이블의 연속된 데이터 페이지가 읽히는 경우, 백그라운드 스레드에서 자동으로 시작되는 작업
  - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측 → 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 가져다 놓음
  - 풀 테이블 스캔 → 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 읽음 → 특정 시점(`innodb_read_ahead_threshold`)에는 백그라운드 스레드로 읽기 위임 
    - 백그라운드 스레드는 한 번에 4~8개의 페이지를 읽으며 그 수를 증가시킴 → 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장
    - 포그라운드 스레드는 버퍼 풀에 준비된 데이터를 가져다 쓰기만 하면 됨
  - 풀 인덱스 스캔에도 동일하게 사용됨
- `select count(*) from employees`
  - 풀 인덱스 스캔으로 읽음 
  - 단순히 레코드 건수만 필요한 경우, 용량이 작은 인덱스를 읽는 것이 더 이득이기 때문 
  - 이는 레코드에만 있는 컬럼이 필요하지 않을 경우에만 해당 


## 9.2.2 병렬 처리 
- **하나의 쿼리**를 여러 스레드가 작업을 나누어 동시에 처리하는 것
  - 여러 스레드가 동시에 각각의 쿼리를 처리하는 것을 의미하는게 아님
- 아무런 `where` 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능 


## 9.2.3 ORDER BY 처리(Using filesort)
### 정렬을 처리하는 방법
- 인덱스를 이용하는 방법
- 쿼리가 실행될 때 Filesort 라는 별도의 처리를 이용하는 방법 

### 장단점 
|             | 장점                                                                                             | 단점                                                                                                                                       |
|-------------|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| 인덱스 이용      | INSERT, UPDATE, DELETE 쿼리 실행 시, 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되므로 매우 빠름                             | - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스를 추가/삭제 작업이 필요하므로 느림<br/> - 인덱스 때문에 디스크 공간이 더 필요<br/> - 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 더 많이 필요 |
| Filesort 이용 | - 인덱스 생성하지 않아도 되므로, 인덱스 이용 시의 단점이 장점임 <br/> - 정렬해야 할 레코드가 많지 않은 경우 메모리에서 Filesort를 처리하여 충분히 빠름 | - 정렬 작업이 쿼리 실행 시 처리 → 레코드 대상 건수가 많아질 수록 응답 속도가 느림                                                                                        |

### 정렬이 인덱스를 이용하기 어려운 경우  
- 정렬 기준이 너무 많아서 요건 별 인덱스를 모두 생성하는 것이 불가능한 경우 
- `GROUP BY` 절이나 `DISTINCT` 절을 이용한 처리 결과를 정렬해야 하는 경우 
- `UNION`의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우 
- 랜덤하게 결과 레코드를 가져와야 하는 경우 


### 9.2.3.1 소트 버퍼 
- 정렬을 수행하기 위해 사용되는 별도의 메모리 공간 
- 정렬이 필요한 경우에만 할당 
- 정렬해야 할 레코드 크기에 따라 가변적으로 증가
  - max = `sort_buffer_size`
- 쿼리 실행 완료 후 즉시 반납
- 세션(로컬) 메모리 영역에 해당
  - 커넥션이 많을수록, 정렬 작업이 많을 수록 소트 버퍼로 소비되는 메모리 공간이 커짐

#### 소량인 경우
- 문제가 안됨. 오히려 빠르게 정렬이 될 것 

#### 대량인 경우
- 정렬해야 할 레코드 건수가 많아, 크기가 소트 버퍼로 할당된 공간보다 큰 경우
- 정렬해야 할 레코드를 여러 조각으로 나누어 처리 
  - 소트 버퍼에 모든 레코드를 저장할 수 없으므로, 디스크에 임시 저장 
  - 메모리의 소트 버퍼에서 정렬 수행 → 결과를 디스크에 임시 저장 → 병합 
    - 병합 작업 = 멀티 머지(Multi Merge)
- 디스크 I/O 유발 
  - 레코드 건수가 많을 수록 작업 횟수 증가 
  - 디스크 I/O가 많아지면서 응답 속도가 느려짐
- 소트 버퍼 크기를 키운다고 해서 해결되지 않음 
  - 오히려, 너무 키울 경우, OOM이 발생하여 OOM-killer가 프로세스를 종료시켜 버릴 것 
  

### 9.2.3.2 정렬 알고리즘
- 레코드 전체를 소트 버퍼에 담을지 vs 정렬 기준 컬럼만 소트 버퍼에 담을지
- 투 패스
  - `<sort_key, rowid>` 
    - 정렬 키와 레코드의 Row ID만 가져와서 정렬 
- 싱글 패스
  - `<sort_key, addtional_fields>`
    - 정렬 키와 전체 레코드를 가져와서 정렬 
    - 레코드의 컬럼들은 고정 사이즈로 메모리 저장
  - `<sort_key, packed_additional_fields>`
    - 정렬 키와 전체 레코드를 가져와서 정렬
    - 레코드 컬럼들은 가변 사이즈로 메모리 저장

    
### 9.2.3.2.1 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 컬럼을 포함하여 `select` 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 방식
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용
- 정렬 대상 레코드 건수가 작은 경우 빠른 성능 

#### 예제
```mysql
select emp_no, first_name, last_name
from employees
order by first_name;
```

![img.png](img.png)
- 정렬에 필요하지 않은 컬럼까지 전부 읽어서 소트 버퍼에 담아 정렬을 수행 
- 정렬 완료 시 정렬 버퍼의 내용을 그대로 클라이언트에게 전달 

### 9.2.3.2.2 투 패스 정렬 방식
- 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행한 후, 정렬 순서대로 PK로 테이블을 읽어서 `select`할 컬럼을 가져오는 정렬 방식
- 테이블을 두 번 읽어야 해서 상당히 불합리한 방식 
  - 싱글 패스에는 이러한 불합리가 없으나, **더 많은 소트 버퍼 공간 필요**
- 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적 

#### 예제
```mysql
select emp_no, first_name, last_name
from employees
order by first_name;
```

![img_1.png](img_1.png)
1. 정렬에 필요한 `first_name`컬럼과 PK인 `emp_no`만 읽어서 정렬 수행 
2. 정렬 결과의 순서대로 `employees` 테이블을 한번 더 읽어서 `last_name`을 가져옴 
3. 최종 결과를 클라이언트에게 반환 


#### 싱글 패스 정렬을 사용하지 못하는 경우 
- 레코드 크기가 `max_length_for_sort_data`에 설정된 값보다 클 때 
- `BLOB`, `TEXT` 타입 컬럼이 `select` 대상에 포함될 때 


#### 주의 
- `select * from...`
  - 소트 버퍼를 몇 배 ~ 몇십 배까지 비효율적으로 사용할 가능성이 큼 
  - `select` 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하는 것이 좋음 
    - 정렬 시 불필요한 컬럼이 없도록 작성하는 것이 효율적임


### 9.2.3.3 정렬 처리 방법 
`order by`가 사용된 경우 아래의 3가지 방법 중 하나로 정렬이 처리됨

| 정렬 처리 방법                    | 실행 계획                                    |
|-----------------------------|------------------------------------------|
| 인덱스를 사용한 정렬                 | 별도 표기 없음                                 |
| 조인에서 드라이빙 테이블만 정렬           | `Using filesort` 메세지 표시                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | `Using temporary; Using filesort` 메세지 표시 |


#### 옵티마이저는 아래의 순서로 검토
1. 인덱스를 이용할 수 있는가?
   - 있다면 인덱스를 순서대로 읽어서 결과를 반환 
2. 없다면 아래 2가지 방법 중 하나로 `Filesort` 수행 
   - 조인의 드라이빙 테이블만 정렬 후 조인 
   - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 

일반적으로, 조인이 수행되면서 레코드 건수와 크기는 거의 배수로 불어남. 가능하다면 **드라이빙 테이블만 정렬 후 조인을 수행하는 방법이 효율적**

> Driving table & Driven Table
> - Driving table
>   - Join 시 먼저 액세스 되는 테이블 
> - Driven table
>   - Join 시 나중에 액세스 되는 테이블 


### 9.2.3.3.1 인덱스를 이용한 정렬
#### 인덱스를 이용한 정렬의 조건 
- `order by`에 명시된 컬럼이 가장 먼저 읽는 테이블에 속해야 함
  - 조인이 사용된 경우 드라이빙 테이블 
- `order by`의 순서대로 생성된 인덱스가 있어야 함 
- `where` 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있는 경우, 해당 조건과 `order by`는 같은 인덱스를 사용할 수 있어야 함 
- `B-Tree` 계열 인덱스만 가능 
  - 해시 인덱스, 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬 사용 불가 
- 여러 테이블이 사용되는 경우 `Nested-loop` 방식의 조인에서만 사용 가능 

> Nested-loop란?
> - 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 조합하는 조인 방식
> - 드라이빙 테이블로 한 테이블을 선정 → 이 테이블로부터 `where` 절에 정의된 검색 조건을 만족하는 데이터를 필터링 → 해당 값으로 조인 대상 테이블을 검색 → 결괏값
> - [참고 자료](https://coding-factory.tistory.com/756)

#### 처리 
- 인덱스 값은 정렬돼 있음 → 인덱스 순서대로 읽기만 하면 됨 
  - 별도의 추가 작업 X 

#### 예제 
```mysql
-- 아래 두 쿼리는 같은 순서로 출력 
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;

-- emp_no로 정렬이 필요한데, 인덱스를 사용하면서 자동 정렬이 된다고 해서 일부러 order by emp_no를 제거하는 것은 좋지 않은 선택
-- 차라리 명시적인 것이 좋음 (성능 상의 손해가 없기 때문)
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020;
```

![img_2.png](img_2.png)
- `employees` 테이블의 PK를 먼저 읽고, 그 다음 `salaries` 테이블을 조인 
- 가능한 이유 
  - `B-Tree` 인덱스가 키 값으로 정렬돼있기 때문 
  - 조인이 `Nested-loop` 방식으로 실행
    - 드라이빙 테이블의 인덱스 순서가 흐트러지지 않음 
- 조인이 사용된 쿼리의 실행 계획에 `Join Buffer`가 사용되면 순서가 흐트러질 수 있기 때문에 주의 필요 

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬 
- 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 방법 
- 드라이빙 테이블의 컬럼만으로 `order by` 절을 작성해야 함 

#### 예제 
```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.last_name;
```
- `employees`가 드라이빙 테이블
  - 이유 (???...)
    - `where` 절의 검색 조건은 `employees` 테이블의 PK를 이용하면 검색 작업량 감소 
    - Driven table인 `salaries` 테이블의 조인 컬럼인 `emp_no` 컬럼에 인덱스 존재
- 검색은 인덱스 레인지 스캔으로 처리 가능
- `order by` 절의 컬럼은 `employees`의 PK와 전혀 연관이 없음 → 인덱스를 이용한 정렬 불가 
- 드라이빙 테이블만 정렬 후 조인 수행 

![img_3.png](img_3.png)
1. 인덱스를 이용해 `e.emp_no BETWEEN 100002 AND 100020` 조건을 만족하는 레코드를 검색 
2. `last_name`을 기준으로 정렬 수행 (`Filesort`)
3. 정렬된 결과를 순서대로 읽으며 `salaries` 테이블과 조인 수행 


### 9.2.3.3.3 임시 테이블을 이용한 정렬 
- 2개 이상의 테이블을 조인해서 결과를 정렬해야 하는 경우 임시 테이블이 필요할 수 있음 
  - "조인의 드라이빙 테이블만 정렬"은 임시 테이블 필요 X
  - 조인의 결과를 임시 테이블에 저장 후 그 결과를 다시 정렬 
- 가장 느린 정렬 방법

#### 예제 
```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY s.salary;
```

![img_4.png](img_4.png)
- `order by`절의 정렬 기준 컬럼이 Driven table인 `salaries`임 
  - 정렬을 수행하기 전에 `salaries` 테이블을 먼저 읽어야 함
  - 따라서, 조인된 데이터를 가지고 정렬할 수밖에 없음 
- 실행 계획
  - `Using temporary; Using filesort` 메세지 표시
  - 임시 테이블 저장 → 정렬 처리 


### 9.2.3.3.4 정렬 처리 방법의 성능 비교 



















