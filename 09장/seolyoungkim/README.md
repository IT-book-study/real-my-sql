# 9.1 개요 
- 실행 계획을 이해할 수 있어야 함
  - 실행 계획의 불합리한 부분을 찾아내어 최적화된 방법을 사용하도록 유도할 수 있음 

## 9.1.1 쿼리 실행 절차 
1. 사용자가 SQL 문장 요청
2. 요청된 SQL 문장을 파싱하여 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
   - SQL 파서라는 모듈이 처리 
   - 문법이 잘못된 경우를 걸러냄 
   - 파스 트리 생성
3. SQL의 파싱 정보인 파스 트리를 확인하면서 어떤 테이블부터 읽고, 어떤 인덱스를 이용할지 선택하여 데이터를 읽어옴
   - 최적화 및 실행 계획 수립 단계 (옵티마이저)
     - 불필요한 조건 제거 
     - 복잡한 연산 단순화 
     - 테이블 조인이 있는 경우, 어떤 순서로 테이블을 읽을 것인지 결정 
     - 각 테이블에 사용된 조건과 인덱스 통계 정보를 토대로 사용할 인덱스 결정 
     - 가져온 레코드들을 임시 테이블에 넣고, 다시 한번 가공해야 하는지 그 여부를 결정 

## 9.1.2 옵티마이저의 종류
### 규칙 기반 최적화(Rule-based Optimizer, RBO)
- 같은 쿼리에 대해 항상 같은 실행 방법
  - 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
  - 대상 테이블의 레코드 건수나 선택도 고려 X 
  - 통계 정보(테이블 레코드 건수, 컬럼값 분포도) 조사 X
- 사용자 데이터는 분포도가 다양하여 이를 고려해야 하기 때문에 거의 사용되지 않는 방식임  

### 비용 기반 최적화(Cost-based Optimizer, CBO)
- 쿼리를 처리하기 위해 여러 가지 가능한 실행 계획을 만듦 
  - 각 단위 작업의 비용(부하) 정보 + 대상 테이블의 예측된 통계 정보 → 실행 계획별 비용 산출 
  - 비용이 최소로 소요되는 처리 방식 선택 
- 대부분의 RDBMS가 사용하는 방식


---

---

# 9.2 기본 데이터 처리 
## 9.2.1 풀 테이블 스캔 & 풀 인덱스 스캔 
### 풀 테이블 스캔(Full Table Scan)
- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어오는 방식
- MySQL 옵티마이저는 아래의 조건이 일치할 때 주로 풀 테이블 스캔 선택 
  - 테이블의 레코드 건수가 적을 때
    - 일반적으로 테이블이 페이지 1개로 구성된 경우 
    - 레코드 건수가 적을 때는 풀 테이블 스캔이 빠르다 
  - `where`, `on` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우 
  - 인덱스 레인지 스캔을 사용할 수 있더라도, 조건 일치 레코드가 너무 많은 경우 
    - ex: 테이블의 절반 이상이 조건에 일치하는 경우
- 리드 어헤드(Read ahead)
  - 특정 테이블의 연속된 데이터 페이지가 읽히는 경우, 백그라운드 스레드에서 자동으로 시작되는 작업
  - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측 → 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 가져다 놓음
  - 풀 테이블 스캔 → 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 읽음 → 특정 시점(`innodb_read_ahead_threshold`)에는 백그라운드 스레드로 읽기 위임 
    - 백그라운드 스레드는 한 번에 4~8개의 페이지를 읽으며 그 수를 증가시킴 → 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장
    - 포그라운드 스레드는 버퍼 풀에 준비된 데이터를 가져다 쓰기만 하면 됨
  - 풀 인덱스 스캔에도 동일하게 사용됨
- `select count(*) from employees`
  - 풀 인덱스 스캔으로 읽음 
  - 단순히 레코드 건수만 필요한 경우, 용량이 작은 인덱스를 읽는 것이 더 이득이기 때문 
  - 이는 레코드에만 있는 컬럼이 필요하지 않을 경우에만 해당 


## 9.2.2 병렬 처리 
- **하나의 쿼리**를 여러 스레드가 작업을 나누어 동시에 처리하는 것
  - 여러 스레드가 동시에 각각의 쿼리를 처리하는 것을 의미하는게 아님
- 아무런 `where` 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능 


## 9.2.3 ORDER BY 처리(Using filesort)
### 정렬을 처리하는 방법
- 인덱스를 이용하는 방법
- 쿼리가 실행될 때 Filesort 라는 별도의 처리를 이용하는 방법 

### 장단점 
|             | 장점                                                                                             | 단점                                                                                                                                       |
|-------------|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| 인덱스 이용      | INSERT, UPDATE, DELETE 쿼리 실행 시, 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되므로 매우 빠름                             | - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스를 추가/삭제 작업이 필요하므로 느림<br/> - 인덱스 때문에 디스크 공간이 더 필요<br/> - 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 더 많이 필요 |
| Filesort 이용 | - 인덱스 생성하지 않아도 되므로, 인덱스 이용 시의 단점이 장점임 <br/> - 정렬해야 할 레코드가 많지 않은 경우 메모리에서 Filesort를 처리하여 충분히 빠름 | - 정렬 작업이 쿼리 실행 시 처리 → 레코드 대상 건수가 많아질 수록 응답 속도가 느림                                                                                        |

### 정렬이 인덱스를 이용하기 어려운 경우  
- 정렬 기준이 너무 많아서 요건 별 인덱스를 모두 생성하는 것이 불가능한 경우 
- `GROUP BY` 절이나 `DISTINCT` 절을 이용한 처리 결과를 정렬해야 하는 경우 
- `UNION`의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우 
- 랜덤하게 결과 레코드를 가져와야 하는 경우 


### 9.2.3.1 소트 버퍼 
- 정렬을 수행하기 위해 사용되는 별도의 메모리 공간 
- 정렬이 필요한 경우에만 할당 
- 정렬해야 할 레코드 크기에 따라 가변적으로 증가
  - max = `sort_buffer_size`
- 쿼리 실행 완료 후 즉시 반납
- 세션(로컬) 메모리 영역에 해당
  - 커넥션이 많을수록, 정렬 작업이 많을 수록 소트 버퍼로 소비되는 메모리 공간이 커짐

#### 소량인 경우
- 문제가 안됨. 오히려 빠르게 정렬이 될 것 

#### 대량인 경우
- 정렬해야 할 레코드 건수가 많아, 크기가 소트 버퍼로 할당된 공간보다 큰 경우
- 정렬해야 할 레코드를 여러 조각으로 나누어 처리 
  - 소트 버퍼에 모든 레코드를 저장할 수 없으므로, 디스크에 임시 저장 
  - 메모리의 소트 버퍼에서 정렬 수행 → 결과를 디스크에 임시 저장 → 병합 
    - 병합 작업 = 멀티 머지(Multi Merge)
- 디스크 I/O 유발 
  - 레코드 건수가 많을 수록 작업 횟수 증가 
  - 디스크 I/O가 많아지면서 응답 속도가 느려짐
- 소트 버퍼 크기를 키운다고 해서 해결되지 않음 
  - 오히려, 너무 키울 경우, OOM이 발생하여 OOM-killer가 프로세스를 종료시켜 버릴 것 
  

### 9.2.3.2 정렬 알고리즘
- 레코드 전체를 소트 버퍼에 담을지 vs 정렬 기준 컬럼만 소트 버퍼에 담을지
- 투 패스
  - `<sort_key, rowid>` 
    - 정렬 키와 레코드의 Row ID만 가져와서 정렬 
- 싱글 패스
  - `<sort_key, addtional_fields>`
    - 정렬 키와 전체 레코드를 가져와서 정렬 
    - 레코드의 컬럼들은 고정 사이즈로 메모리 저장
  - `<sort_key, packed_additional_fields>`
    - 정렬 키와 전체 레코드를 가져와서 정렬
    - 레코드 컬럼들은 가변 사이즈로 메모리 저장

    
### 9.2.3.2.1 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 컬럼을 포함하여 `select` 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 방식
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용
- 정렬 대상 레코드 건수가 작은 경우 빠른 성능 

#### 예제
```mysql
select emp_no, first_name, last_name
from employees
order by first_name;
```

![img.png](img.png)
- 정렬에 필요하지 않은 컬럼까지 전부 읽어서 소트 버퍼에 담아 정렬을 수행 
- 정렬 완료 시 정렬 버퍼의 내용을 그대로 클라이언트에게 전달 

### 9.2.3.2.2 투 패스 정렬 방식
- 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행한 후, 정렬 순서대로 PK로 테이블을 읽어서 `select`할 컬럼을 가져오는 정렬 방식
- 테이블을 두 번 읽어야 해서 상당히 불합리한 방식 
  - 싱글 패스에는 이러한 불합리가 없으나, **더 많은 소트 버퍼 공간 필요**
- 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적 

#### 예제
```mysql
select emp_no, first_name, last_name
from employees
order by first_name;
```

![img_1.png](img_1.png)
1. 정렬에 필요한 `first_name`컬럼과 PK인 `emp_no`만 읽어서 정렬 수행 
2. 정렬 결과의 순서대로 `employees` 테이블을 한번 더 읽어서 `last_name`을 가져옴 
3. 최종 결과를 클라이언트에게 반환 


#### 싱글 패스 정렬을 사용하지 못하는 경우 
- 레코드 크기가 `max_length_for_sort_data`에 설정된 값보다 클 때 
- `BLOB`, `TEXT` 타입 컬럼이 `select` 대상에 포함될 때 


#### 주의 
- `select * from...`
  - 소트 버퍼를 몇 배 ~ 몇십 배까지 비효율적으로 사용할 가능성이 큼 
  - `select` 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하는 것이 좋음 
    - 정렬 시 불필요한 컬럼이 없도록 작성하는 것이 효율적임


### 9.2.3.3 정렬 처리 방법 
`order by`가 사용된 경우 아래의 3가지 방법 중 하나로 정렬이 처리됨

| 정렬 처리 방법                    | 실행 계획                                    |
|-----------------------------|------------------------------------------|
| 인덱스를 사용한 정렬                 | 별도 표기 없음                                 |
| 조인에서 드라이빙 테이블만 정렬           | `Using filesort` 메세지 표시                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | `Using temporary; Using filesort` 메세지 표시 |


#### 옵티마이저는 아래의 순서로 검토
1. 인덱스를 이용할 수 있는가?
   - 있다면 인덱스를 순서대로 읽어서 결과를 반환 
2. 없다면 아래 2가지 방법 중 하나로 `Filesort` 수행 
   - 조인의 드라이빙 테이블만 정렬 후 조인 
   - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 

일반적으로, 조인이 수행되면서 레코드 건수와 크기는 거의 배수로 불어남. 가능하다면 **드라이빙 테이블만 정렬 후 조인을 수행하는 방법이 효율적**

> Driving table & Driven Table
> - Driving table
>   - Join 시 먼저 액세스 되는 테이블 
> - Driven table
>   - Join 시 나중에 액세스 되는 테이블 


### 9.2.3.3.1 인덱스를 이용한 정렬
#### 인덱스를 이용한 정렬의 조건 
- `order by`에 명시된 컬럼이 가장 먼저 읽는 테이블에 속해야 함
  - 조인이 사용된 경우 드라이빙 테이블 
- `order by`의 순서대로 생성된 인덱스가 있어야 함 
- `where` 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있는 경우, 해당 조건과 `order by`는 같은 인덱스를 사용할 수 있어야 함 
- `B-Tree` 계열 인덱스만 가능 
  - 해시 인덱스, 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬 사용 불가 
- 여러 테이블이 사용되는 경우 `Nested-loop` 방식의 조인에서만 사용 가능 

> Nested-loop란?
> - 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 조합하는 조인 방식
> - 드라이빙 테이블로 한 테이블을 선정 → 이 테이블로부터 `where` 절에 정의된 검색 조건을 만족하는 데이터를 필터링 → 해당 값으로 조인 대상 테이블을 검색 → 결괏값
> - [참고 자료](https://coding-factory.tistory.com/756)

#### 처리 
- 인덱스 값은 정렬돼 있음 → 인덱스 순서대로 읽기만 하면 됨 
  - 별도의 추가 작업 X 

#### 예제 
```mysql
-- 아래 두 쿼리는 같은 순서로 출력 
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;

-- emp_no로 정렬이 필요한데, 인덱스를 사용하면서 자동 정렬이 된다고 해서 일부러 order by emp_no를 제거하는 것은 좋지 않은 선택
-- 차라리 명시적인 것이 좋음 (성능 상의 손해가 없기 때문)
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020;
```

![img_2.png](img_2.png)
- `employees` 테이블의 PK를 먼저 읽고, 그 다음 `salaries` 테이블을 조인 
- 가능한 이유 
  - `B-Tree` 인덱스가 키 값으로 정렬돼있기 때문 
  - 조인이 `Nested-loop` 방식으로 실행
    - 드라이빙 테이블의 인덱스 순서가 흐트러지지 않음 
- 조인이 사용된 쿼리의 실행 계획에 `Join Buffer`가 사용되면 순서가 흐트러질 수 있기 때문에 주의 필요 

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬 
- 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 방법 
- 드라이빙 테이블의 컬럼만으로 `order by` 절을 작성해야 함 

#### 예제 
```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.last_name;
```
- `employees`가 드라이빙 테이블
  - 이유 (???...)
    - `where` 절의 검색 조건은 `employees` 테이블의 PK를 이용하면 검색 작업량 감소 
    - Driven table인 `salaries` 테이블의 조인 컬럼인 `emp_no` 컬럼에 인덱스 존재
- 검색은 인덱스 레인지 스캔으로 처리 가능
- `order by` 절의 컬럼은 `employees`의 PK와 전혀 연관이 없음 → 인덱스를 이용한 정렬 불가 
- 드라이빙 테이블만 정렬 후 조인 수행 

![img_3.png](img_3.png)
1. 인덱스를 이용해 `e.emp_no BETWEEN 100002 AND 100020` 조건을 만족하는 레코드를 검색 
2. `last_name`을 기준으로 정렬 수행 (`Filesort`)
3. 정렬된 결과를 순서대로 읽으며 `salaries` 테이블과 조인 수행 


### 9.2.3.3.3 임시 테이블을 이용한 정렬 
- 2개 이상의 테이블을 조인해서 결과를 정렬해야 하는 경우 임시 테이블이 필요할 수 있음 
  - "조인의 드라이빙 테이블만 정렬"은 임시 테이블 필요 X
  - 조인의 결과를 임시 테이블에 저장 후 그 결과를 다시 정렬 
- 가장 느린 정렬 방법

#### 예제 
```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY s.salary;
```

![img_4.png](img_4.png)
- `order by`절의 정렬 기준 컬럼이 Driven table인 `salaries`임 
  - 정렬을 수행하기 전에 `salaries` 테이블을 먼저 읽어야 함
  - 따라서, 조인된 데이터를 가지고 정렬할 수밖에 없음 
- 실행 계획
  - `Using temporary; Using filesort` 메세지 표시
  - 임시 테이블 저장 → 정렬 처리 


### 9.2.3.3.4 정렬 처리 방법의 성능 비교 
- `order by`, `group by`는 `limit` 건수 만큼만 가져와서는 처리 불가 
  - 조건 만족하는 모든 레코드를 가져와서 정렬 수행 or 그루핑 작업을 실행한 후에야 `limit` 제한 가능 
- `where` 조건이 인덱스를 잘 탄다 해도, 잘못된 `order by`, `group by`로 인해 쿼리가 느려지는 경우가 자주 발생 

인덱스를 사용하지 못하는 정렬이나 그루핑 작업은 왜 느리가 동작할 수 밖에 없는가? 

### 9.2.3.3.4.1 스트리밍 방식
- 처리할 데이터의 양과 관계 없이, 조건에 일치하는 레코드가 검색될 때마다 즉시 클라이언트로 전송해주는 방식 
- 빠른 응답 속도 보장 
  - 첫 번째 레코드를 즉시 전송하므로 
- 스트리밍 방식에서는 `LIMIT`처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줌
- 인덱스를 사용한 정렬 방식이 스트리밍 방식으로 처리됨 

### 9.2.3.3.4.2 버퍼링 방식
- `order by`, `group by`는 쿼리 결과가 스트리밍되는 것을 불가능하게 함 
  - `where` 조건에 해당하는 모든 레코드를 가져옴 → 정렬 or 그루핑 수행 → 이후에 `limit` 적용 
  - 완료될 때까지 클라이언트는 대기 
- 응답 속도가 느려짐
- `limit`이 있어도 성능 향상에 별 도움이 안됨
- 인덱스를 사용한 정렬 방식 **이외의 모든 방식은 버퍼링 방식으로 처리됨**

#### 참고 
- JDBC 라이브러리를 사용할 때는..
  - MySQL이 스트리밍으로 전송해도 JDBC 내부에서 버퍼링 
  - JDBC가 버퍼링을 하는 이유는 **MySQL 서버와의 통신 횟수를 적게 하기 위함** 
    - 즉, 네트워크 I/O를 줄이기 위함


#### Join + Order by + Limit
```mysql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1 = t2.col1
ORDER BY t1.col2
LIMIT 10;
```
- 조건 
  - tb_test : 100건
  - tb_test2 : 1,000건
  - tb_test1 레코드 1건 당 tb_test2 레코드 10건이 존재
  - 두 테이블의 조인 결과는 전체 1,000건

- 결과
  - ![img_5.png](img_5.png)
  - ![img_6.png](img_6.png)

- 가능하면 인덱스를 사용한 정렬을 유도 
  - 안될 경우 최소한 드라이빙 테이블 정렬 

### 9.2.3.4 정렬 관련 상태 변수 
- MySQL 서버는 처리하는 주요 작업에 대해, 해당 작업의 실행 횟수를 상태 변수로 저장 
  - 몇 건의 레코드나 정렬 처리를 수행했는지 
  - 소트 버퍼 간 병합 작업(멀티 머지)는 몇 번이나 발생했는지 
- 자세한 내용은 책 참고 


## 9.2.4 GROUP BY 처리
- 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나 
- `Having` 절은 인덱스를 사용해서 처리될 수 없음 → 튜닝 고민 하지마... 

### 9.2.4.1 인덱스 스캔을 이용
- 조인의 드라이빙 테이블에 속한 컬럼만 이용하여 그루핑할 때 
  - `group by` 컬럼으로 이미 인덱스가 있는 경우 
    - 해당 인덱스를 차례대로 읽으면서 그루핑 작업 수행
    - 조인 처리
- 이미 정렬된 인덱스를 읽는 것
  - 쿼리 실행 시점에 추가적인 정렬 작업이나, 내부 임시 테이블은 필요하지 않음 
    - 그룹 함수 등의 그룹 값을 처리해야 하는 경우에는 임시 테이블이 필요할 수 있음
- 실행 계획의 `Extra`컬럼에 `group by` 관련 코멘트에 별 내용이 기재되지 않음 

### 9.2.4.2 루스 인덱스 스캔을 이용 
- 인덱스의 레코드를 건너 뛰면서 필요한 부분만 가져오는 것 
- 실행 계획의 `Extra`컬럼에 `Using index for group-by` 코멘트가 표시
- 단일 테이블에 대해 수행되는 `group by`에만 사용 가능
- 프리픽스 인덱스는 사용 불가 
  - prefix index: 인덱스의 앞쪽 일부만 사용하는 인덱스
- 별도의 임시 테이블이 필요하지 않음 
- 루스 인덱스 스캔을 사용할 수 있는 쿼리
  - ![img_7.png](img_7.png)
- 사용 불가능한 쿼리
  - ![img_8.png](img_8.png)

#### 예제 
```mysql
SELECT emp_no
FROM salaries
WHERE from_date='1985-03-01'
GROUP BY emp_no;
```
- 위 salaries 테이블의 인덱스는 `(emp_no, from_date)`로 생성돼 있음 
  - `where` 조건은 인덱스 레인지 스캔 접근 방식으로 이용 불가 
  - 하지만 `group by`가 인덱스로 구성되어 있어 루스 인덱스 스캔을 사용할 수 있음

#### 작동 순서
1. `(emp_no, from_date)` 인덱스를 차례로 스캔 
2. `emp_no`의 첫 번째 값인 `10001`을 찾음 
3. `emp_no`가 `10001`인 것 중에서 `from_date`가 `1985-03-01`인 레코드만 가져옴 
   - 이는 `emp_no=10001 and from_date='1985-03-01'` 조건을 만족하는 레코드를 가져오는 것과 동일함 
4. `emp_no`의 다음 값인 `10002`를 찾음
5. 3번 과정으로 돌아가서 반복 수행 
   - 결과가 없을 경우 처리 종료


### 9.2.4.3 임시 테이블 
- 인덱스를 전혀 사용하지 못할 때 사용하는 방법
- 실행 계획의 `Extra` 컬럼에 `Using temporary` 코멘트가 표시됨
- `group by` 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 생성
  - 중복 제거와 집합 함수 연산을 수행 
  - 조인 결과를 한 건씩 가져와 임시 테이블에서 중복 체크 → insert, update 실행 
- `group by`, `order by`가 같이 사용되면 명시적으로 정렬 실행 


## 9.2.5 DISTINCT 처리
- 집합 함수 유무에 따라 영향 범위가 달라짐 
- 인덱스를 사용하지 못할 경우 임시 테이블을 사용
- `Using temporary` 코멘트가 표시되지 않음


### 9.2.5.1 SELECT DISTINCT ... 
- `select`되는 레코드 중에서 유니크한 레코드만 가져오고자 하는 경우 사용 
- `group by`와 유사한 처리 방식 (아래 두 쿼리는 내부적으로 같은 작업 수행)
  - `select distinct emp_no from salaries`
  - `select emp_no from salaries group by emp_no`
- `distinct`는 레코드(튜플)를 유니크하게 `select`하는 것이지, 특정 컬럼만 유니크하게 조회하는 게 아님 
  - `select distinct first_name, last_name from employees`
    - 이는 `first_name`만 유니크한 것을 가져오는 게 아니라, `(first_name, last_name)` 조합 전체가 유니크한 레코드를 가져오는 것
- `select`절에 사용된 `distinct`는 조회되는 모든 컬럼에 영향 
  

### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT
- `count()`, `min()`, `max()`와 같은 집합 함수와 함께 사용할 때 
  - 집합 함수의 인자로 전달된 컬럼 값이 유니크한 것들을 가져옴


- 인덱스를 이용할 수 없을 때 임시 테이블 이용
  - `select count(distinct s.salary) from employees e, salaries s...`
    - `count(distinct s.salary)`를 처리하기 위해 임시 테이블 이용 
      - `employees`, `salaries` 테이블을 조인한 결과에서 `salary` 컬럼 값만 저장하기 위한 임시 테이블을 생성함
    - `Using temporary` 코멘트가 표시되지 않음


- 인덱스 풀 스캔 or 레인지 스캔 (임시 테이블 x)
  - `emp_no`: PK
  - `select count(distinct emp_no) from employees`
  - `select count(distinct emp_no) from dept_emp group by dept_no`


## 9.2.6 내부 임시테이블 활용 
- 정렬 or 그루핑을 수행할 때 내부적인 임시 테이블 사용 
- 메모리에 생성 → 크기가 커지면 디스크로 이동 
- 내부적으로 생성하는 것은 보거나 이용 불가 
- 쿼리 완료 시 자동 삭제

### 9.2.6.1 메모리 임시 테이블 & 디스크 임시 테이블 
#### 메모리에 저장되는 임시 테이블
- `TempTable` 스토리지 엔진 사용
  - 가변 길이 타입 지원 
#### 디스크에 저장되는 임시 테이블
- `InnoDB` 스토리지 엔진 사용
  - 트랜잭션 지원 
- 메모리 → 디스크 변환 방식  
  - `MMAP` 파일로 디스크에 기록 → default
    - `InnoDB` 테이블 변환 방식보다 오버헤드가 더 적음 
  - `InnoDB` 테이블로 기록 
    - 디스크 즉시 기록 시 `InnoDB` 테이블 사용 
- 파일 오픈 후 즉시 파일 삭제 (참조가 끊기면 자동 삭제됨)


### 9.2.6.2 임시 테이블이 필요한 쿼리
#### `Using temporary` 코멘트가 표시되는 쿼리
- `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
- `ORDER BY`나 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리

#### `Using temporary` 코멘트가 표시되지 않는 쿼리
- `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`이나 `UNION DISTINCT`가 사용된 쿼리(`select_type` 칼럼이 `UNION RESULT`인 경우)
- 쿼리의 실행 계획에서 `select_type`이 `DERIVED`인 쿼리


### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우 
- `union` or `union all`에서 `select`되는 컬럼 중, 길이가 512바이트 이상인 크기의 컬럼이 있는 경우 
- `group by` or `distinct` 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 `tmp_table_size` or `max_heap_table_size`보다 크거나 (`TempTable`엔진에서) `temp_max_ram`보다 큰 경우 


### 9.2.6.4 임시 테이블 관련 상태 변수 
- `show session status like 'Created_tmp%'`로 확인 
  - 생성된 내부 임시 테이블 개수 (메모리 + 디스크)
  - 디스크에 내부 임시 테이블이 만들어진 개수 

---

---

# 9.3 고급 최적화 
## 9.3.1 옵티마이저 스위치 옵션 
- `optimizer_switch` 시스템 변수를 이용해 제어 
  - 조인 알고리즘 사용 여부, 기능 사용 여부, 최적화 방식 사용 여부 등을 설정 
- 글로벌, 세션 별 모두 설정 가능한 시스템 변수 

### 9.3.1.1 MRR과 배치 키 액세스
- 매뉴얼에서는 DS-MRR(Disk Sweep MRR) 이라고도 함
- 조인 처리 → MySQL 엔진이 수행
  - 레코드 검색 및 조회 → 스토리지 엔진이 수행
- Nested-loop join
  - 드라이빙 테이블의 레코드를 한 건 읽어서, 드리븐 테이블의 일치하는 레코드를 찾아서 조인 수행
  - 이런 방식의 조인 처리를 수행할 경우, **레코드를 찾고 읽는 스토리지 엔진에서는 수행할 수 있는 최적화가 없음**
- MRR
  - 드라이빙 테이블의 레코드를 읽어서 조인 버퍼에 버퍼링 (조인 즉시 실행 x)
  - 조인 버퍼에 레코드가 가득 차면, 버퍼링된 레코드를 스토리지 엔진으로 한 번에 검색/조회 요청
  - 스토리지 엔진이 읽어야할 레코드들을 데이터 페이지에 정렬된 순서로 접근
  - 디스크 데이터 페이지 읽기(또는 버퍼 풀에 있는 페이지 읽기) 최소화 
- BKA(Batched Key Access)
  - MRR을 응용하여 실행되는 조인 방식 
  - 부가적인 정렬 작업이 필요해지면서 오히려 성능에 안좋은 영향을 미치는 경우도 있음


### 9.3.1.2 블록 네스티드 루프 조인(block nested loop join)
- Nested-loop join 
  - 중첩된 반복 명령을 사용하는 것 처럼 작동한다고 해서 지어진 이름
    - 드라이빙 테이블의 레코드를 한 건 읽고 → 드리븐 테이블의 일치하는 레코드를 찾음 → 조인 수행
  - 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
  - 별다른 버퍼 공간에 저장하지 않으며, 드리븐 테이블의 레코드를 즉시 찾아 반환함
- 조인 버퍼 사용 여부 
  - 조인 알고리즘에 `Block`이라는 단어가 사용된 경우, 별도의 버퍼가 사용되었음을 의미
    - `Block Nested Loop` 조인은 "조인 버퍼를 사용한 Nested-loop 조인"이라는 의미
  - 조인 쿼리 실행 계획의 Extra 컬럼에 `Using Join buffer`문구가 사용된 경우, 조인 버퍼를 사용한다는 것을 의미함 
- 조인 방법 
  - 드라이빙 테이블에서 일치하는 레코드 건수만큼 드리븐 테이블을 검색하면서 처리 
    - 즉, 드라이빙 테이블은 한번에 쭉 읽음 
    - 반면에, 드리븐 테이블은 여러 번 읽게됨 
    - 인덱스를 이용할 수 없는 경우, 드리븐 테이블은 드라이빙 테이블의 일치 건수만큼 풀스캔을 하게된다 
  - 드리븐 테이블의 풀 테이블 스캔 or 인덱스 풀 스캔을 피할 수 없다면... 
    - 드라이빙 테이블에서 읽은 레코드를 조인 버퍼에 캐시 
    - 드리븐 테이블과 조인 버퍼를 조인 

#### 예제 
```mysql
select *
from dept_emp de, employees e
where de.from_Date > '1995-01-01' and e.emp_no < 109004;
```
![img_9.png](img_9.png)
![img_10.png](img_10.png)
1. `dept_emp`테이블의 `ix_dept_emp_from_date` 인덱스를 이용해 조건을 만족하는 레코드 검색
2. 조인에 필요한 나머지 컬럼들을 `dept_emp`에서 읽어서 조인 버퍼에 저장 
3. `employees` 테이블의 PK를 이용해 조건을 만족하는 레코드 검색 
4. 3번에서 검색된 결과를 기준으로 2번의 조인 버퍼에 캐시된 레코드를 결합하여 반환
   - 즉, 드리븐 테이블을 먼저 읽고, 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리
   - 조인이 수행된 후 가져오는 결과는 드라이빙 테이블 순서에 의해 결정됨
     - 하지만, 조인 버퍼가 사용되는 조인에서는 작동 방식 때문에 결과의 정렬 순서가 흐트러질 수 있음 


> MySQL 8.0.20 부터는 블록 네스티드 루프 조인은 사용되지 않고 **해시 조인 알고리즘**이 사용됨  


### 9.3.1.3 인덱스 컨디션 푸시다운 

 