# 08 인덱스_part1

## 8.1 디스크 읽기 방식

- 디스크 읽기 방식에는 **랜덤(Random) I/O` 와 `순차(Sequential) I/O` 방식이 있다.
- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일때가 많다.

###  8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- 하드 디스크 드라이브: 기계식 장치
    - 디스크 원판을 기계적으로 회전시켜 데이터를 읽는다.
- 솔리드 스테이트 드라이브: 전자식 장치
    - 원판을 제거하고 플래시 메모리를 장착해 빠르게 데이터를 읽고 쓴다.


- 순차 I/O 에서는 디스크의 헤더를 움직이지 않아 SSD와 HDD 가 비슷한 성능을 보인다.
- 랜덤 I/O 에서는 랜덤으로 디스크를 읽기 때문에 SSD가 더 빠르게 동작한다.


### 8.1.2 랜덤 I/O와 순차 I/O
- 랜덤 I/O
    - 하드 디스크에서는 원판을 돌려 읽어야할 데이터가 저장된 위치로 헤더를 이동시켜 데이터를 읽는다.
    - 이때 데이터를 읽고 쓸 위치가 순차적이지 않기 때문에 헤더를 위치까지 옮기는데 시간이 걸린다.
    - 따라서 헤더를 움직일 필요가 없는 SSD가 HDD 보다 데이터를 읽는데 유리하다.
- 쿼리를 랜덤 I/O에서 순차 I/O 로 바꿔 실행할 방법은 많지 않기 때문에 쿼리 튜닝은 랜덤 I/O의 시간을 줄여주는 것이 목표이다.


## 8.2 인덱스란?
- 칼럼들의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어두는 것
- 컬럼의 값을 주어진 순서대로 미리 정렬해 보관하기 때문에 찾고자 하는 데이터를 최대한 빠르게 찾을 수 있다.


- 프로그래밍 언어의 자료구조와의 비교
    - SortedList
        - 저장되는 값을 항상 정렬된 상태로 유지
        - 값이 항상 정렬되어야 하기 때문에 저장하는 과정이 복잡하고 느리다
        - 값이 정렬되어 있기 때문에 원하는 값을 빠르게 찾을 수 있다.
    - ArrayList
        - 값을 저장되는 순서 그대로 유지
    - DBMS의 인덱스
        - 저장되는 컬럼의 값을 이용해 SortedList 처럼 정렬해 저장한다.
        - 데이터 파일 자체는 ArrayList와 같이 별도의 정렬 없이 그대로 저장하고, 컬럼 값을 이용해 저장된 전체 데이터를 찾는다.


- 결론적으로 인덱스를 하나 더 추가할지 말지는 저장 속도를 어디까지 희생하고, 읽기 속도를 얼마나 빠르게 만들어야 하는지에 따라 달라진다.

### 역할 별 인덱스의 구분
- 프라이머리 키: 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
    - 테이블에서 해당 레코드를 식별할 수 있는 기준 값
    - NULL과 중복이 허용되지 않는다.
- 세컨더리 인덱스: 프라이머리 키를 제외한 모든 인덱스

### 데이터 저장 방식 별 인덱스의 구분
- B-Tree 인덱스: 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱 하는 알고리즘
- Hash 인덱스: 컬럼의 값으로 해시값을 계산해 인덱싱 하는 알고리즘
    - 값의 일부만 검색하거나 범위 검색에는 사용할 수 없다.

### 데이터의 중복 허용 여부 별 인덱스의 구분
- 유니크 인덱스: 데이터의 중복이 허용되지 않는 인덱스
- 유니크하지 않은 인덱스: 데이터의 중복이 허용되는 인덱스

### 인덱스의 기능별 분류
- 전문 검색용 인덱스
- 공간 검색용 인덱스


## 8.3 B-Tree 인덱스
- 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.

### 8.3.1 구조 및 특성
- B-Tree 이름처럼 트리 구조로 되어있으며 이진 트리로 되어있지는 않다.
    - 최상위 **루트 노드**
    - 중간의 **브랜치 노드**
    - 가장 하위 **리프 노드**
- 데이터베이스에서는 인덱스와 실제 데이터는 따로 관리되는데 실제 데이터의 주소는 리프노드가 가지고 있다.
    - 노드들은 인덱스의 키 값으로 모두 정렬되어있지만 실제 데이터는 정렬되어있지 않는다.
- InnoDB 테이블에서 레코드는 클러스터 되어 디스크에 저장되기 때문에 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
  > 클러스터링: 비슷한 값을 최대한 모아서 저장하는 방식


#### MyISAM 테이블과 InnoDB 스토리지 엔진 테이블의 인덱싱 차이
- 가장 큰 차이는 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방법
    - MyISAM은 세컨더리 인덱스가 물리적인 주소를 가진다.
    - InnoDB 테이블은 프라이머리 키를 주소처럼 사용해 논리적 주소를 가진다.


- MyISAM 테이블의 인덱스
    - 레코드가 테이블에 INSERT 된 순번이나 데이터 파일 내의 위치에 따라 레코드 주소가 생성된다.
- InnoDB 스토리지 엔진 테이블의 인덱스
    - 프라이머리 키가 ROWID의 역할
    - 데이터 파일을 바로 찾아가지 못하고 프라이머리 키 값을 이용해 인덱스를 한번 더 검색한 후 인덱스 리프 페이지에 저장된 레코드를 읽는다.
    - **모든 세컨더리 인덱스 검색에서 레코드를 읽기 위해서는 반드시 B-Tree를 다시 한번 검색해야한다.**


### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 추가
- 저장될 키 값을 이용해 B-Tree의 위치를 검색
- 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장
- 리프노드가 꽉 찰 경우 리프 노드를 분리하며 상위 브랜치 노드까지 처리해야한다.
- 따라서 B-Tree 는 상대적으로 쓰기 작업에 비용이 많이 들어간다.
    - 이미 저장된 인덱스가 많을수록 더 많은 비용이 들어간다.


- MyISAM, MEMORY 스토리지 엔진 사용 테이블의 경우 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
- InnoDB 스토리지 엔진은 필요시 지연처리 할 수 있지만 프라이머리 키나 유니크 인덱스의 경우 중복체크가 필요해 즉시 B-Tree에 추가하거나 삭제한다.


#### 8.3.2.2 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크한다.
- 삭제 마킹된 공간은 방치하다 필요시 재활용한다.


#### 8.3.2.3 인덱스 키 변경
- 키 값에 따라 리프 노드의 위치가 결정되기 때문에 키 값은 단순히 변경할 수 없다.
- 따라서 변경이 아닌 인덱스 키 삭제 후 새로운 키 값을 추가하는 형태로 처리한다.


#### 8.3.2.4 인덱스 키 검색
- 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프노드 까지 이동하며 비교 작업을 수행하는 **트리 탐색** 을 진행한다.
- SELECT 뿐만이 아닌 UPDATE, DELETE 에서 사용되는 조건에도 적용된다.
    - B-Tree 인덱스를 이요한 검색은 100% 일치/값의 앞부분 일치/부등호 에서 사용할 수 있다.
    - 키 값의 뒷부분만 검색하는 용도로는 사용하지 못한다.
- InnoDB 테이블에서는 레코드 잠금이나 넥스트 키락을 인덱스를 잠근 후 레코드를 잠그는 방식으로 구현하기 때문에 적절한 인덱스 설계가 없다면 불필요하게 많은 레코드를 잠글 수 있다.


### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

#### 8.3.3.1 인덱스 키 값의 크기
- 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위를 **페이지** 또는 **블록** 이라하며 페이지는 버퍼풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.
- 인덱스 또한 페이지 단위로 관리되며 루트, 브랜치, 리프 노드를 구분하는 기준도 페이지 단위이다.


- 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 개수가 가변적으로 정해지는 구조이다.
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘고, 그만큼 속도가 느려진다.
- 인덱스 키 값의 길이가 길어지면 전체적인 인덱스의 크기가 커져 메모리에 캐시할 수 있는 레코드 수가 줄어들기 때문에 메모리 효율이 떨어지는 결과를 가져온다.

#### 8.3.3.2 B-Tree 깊이
- 깊이는 직접 제어할 방법이 없지만 MySQL에서 값을 검색할 때 몇번이나 랜덤하게 디스크를 읽어야하는 문제로 직결된다.
- 인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스의 수가 적어지고, 그만큼 같은 레코드 건수라도 깊이가 깊어져 디스크 읽기가 더 많이 필요하게 된다.
- 따라서 **인덱스 키 값의 크기는 가능하면 작게 만드는것이 좋다.**


#### 8.3.3.3 선택도(기수성)
- 모든 인덱스의 키 값 가운데 유니크한 값의 수를 의미한다.
- 중복된 값이 많아지면 기수성이 낮아지는데 중복된 값이 적어 기수성이 높을수록 검색 대상이 줄어들어 처리 속도가 빨라진다.
> 선택도가 좋지 않다해도 정렬이나 그룹핑 같은 작업을 위해 인덱스를 만드는것이 좋은 경우가 있다.


#### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는것보다 많은 비용이 드는 작업이다.
- 따라서 인덱스를 이용한 읽기를 할때 전체 테이블 레코드의 20% ~ 25% 를 넘어서면 인덱스를 이용하지 않고 테이블 조회 후 필요한 레코드만 가려내는 필터링 방식으로 처리하는것이 효율적이다.


### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔
- 인덱스를 통해 여러 레코드를 읽을 때를 인덱스 레인지 스캔이라고 한다.
- 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방식으로 루트, 브랜치, 리프 노드를 찾아 레코드의 시작점을 찾고 시작점에서부터 레코드를 순서대로 읽는다.
- 최종적으로 멈춰야할 위치에 다다르면 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.


- 데이터 파일 자체는 순서대로 저장되어있지 않지만 인덱스 자체의 저열 특성으로 데이터를 읽을 때 순서대로 읽게 된다.
- 이때 데이터 파일에서 레코드를 읽어오는 과정이 있고 한 건 단위로 랜덤 I/O가 한번씩 일어나기 때문에 데이터 레코드의 양이 많을 경우 인덱스를 통한 읽기 보다는 데이터를 직접 읽는 게 효율적이다.
> 1. 인덱스 탐색: 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다
> 2. 인덱스 스캔: 필요한 만큼 인덱스를 차례로 쭉 읽는다.
> 3. 스캔이 끝난 인덱스 키와 주소를 이용해 레코드가 저장된 페이지를 가져오고, 레코드를 읽어온다.
     >    - 커버링 인덱스의 경우 3번의 과정은 생략된다.


#### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우/쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 사용된다.

#### 8.3.4.3 루스 인덱스 스캔
- 인덱스 레인지나 인덱스 풀 스캔은 타이트 인덱스 스캔으로 분류한다.
- 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 스캔한다.
- where 조건을 만족하는 범위를 전체 다 스캔하는게 아닌 일부 만족하지 않는 레코드를 무시하고 다음 레코드로 이동하는 방식으로 스캔한다.

#### 8.3.4.4 인덱스 스킵 스캔
- 옵티마이저가 쿼리에 작성되지 않은 인덱스 컬럼의 유니크한 값을 모두 조회해 주어진 쿼리에 조건을 추가해 다시 실행하는 형태로 처리한다.
- 조건에 작성되지 않은 선행 컬럼의 유니크한 값의 개수가 적어야하고, 쿼리가 인덱스에 존재하는 컬럼만으로 처리(커버링 인덱스)가 가능해야한다는 단점이 있다.


### 8.3.5 다중 컬럼 인덱스
- 두개 이상의 컬럼으로 구성된 인덱스를 의미하며 Concatenated Index 라고도 한다.
- 두번째 컬럼부터는 앞선 컬럼에 의존해 정렬되기 때문에 인덱스 내 각 컬럼의 순서가 중요하다.


### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스를 거꾸로 끝부터 읽으면 내림차순으로 정렬된 인덱스로 사용이 가능하고, 옵티마이저는 쿼리에 따라 실시간으로 실행 계획을 생성해 실행한다.

#### 8.3.6.1 인덱스의 정렬
- MySQL 8.0 버전부터는 정렬 순서를 혼합한 인덱스의 생성이 가능해졌다.

##### 8.3.6.1.1 인덱스 스캔 방향
- 정렬 순서에 따라 더 간단한 방법이 무엇인지 옵티마이저는 알고 있기 때문에 쿼리에 따라 인덱스의 접근 위치를 바꿔 스캔한다.

##### 8.3.6.1.2 내림차순 인덱스
- 인덱스에서 각각의 칼럼이 내림차순과 오름차순으로 혼합된 경우 내림차순 인덱스로만 해결할 수 있다.
- 일반적으로 인덱스를 DESC 하는 쿼리가 소량의 레코드에 드물게 실행되는 경우에는 내림차순 인덱스를 굳이 고려할 필요는 없다.


### 8.3.7 B-Tree 인덱스의 가용성과 효율성

#### 8.4.7.1 비교 조건의 종류와 효율성
- 인덱스를 통해 레코드가 나머지 조건에 맞는지 비교하며 취사선택하는 작업을 **필터링** 이라고 한다.
- 조건의 구분
  - 작업 범위 결정 조건: 작업의 범위를 결정하는 조건
  - 필터링 조건(체크 조건): 작업의 범위를 줄이지 못하고 걸러주는 역할만 하는 조건
- 작업 범위를 결정하는 조건이 많을수록 쿼리 처리 속도는 높아지지만 체크조건이 많은건 쿼리 처리 성능을 높이지 못한다.

#### 8.3.7.2 인덱스의 가용성
- B-Tree 인덱스의 특징은 왼쪽 값에 기준해 오른쪽 값이 정렬된다.
- 따라서 인덱스의 선행 컬럼의 조건이 작업 범위 결정 조건으로 들어가있어야 인덱스를 올바르게 사용할 수 있다.


#### 8.3.7.3 가용성과 효율성 판단
- 아래의 조건에서는 작업 범위 결정 조건으로 사용할 수 없다.
  - NOT-EQUAL로 비교되는 경우
  - LIKE '%??'(뒷부분 일치) 형태로 문자열 패턴이 비교되는 경우
  - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변경 후 비교되는 경우
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - 데이터 타입이 서로 다른 비교(인덱스 컬럼 타입을 변환)하는 경우
  - 문자열 데이터 타입의 콜레이션이 다른 경우
- 다중 컬럼의 인덱스의 조건
  - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - 선행 인덱스 컬럼에 대한 조건이 없는 경우
    - 선행 인덱스 컬럼 비교 조건이 작업 범위 결정 조건으로 사용할 수 없는 경우
  - 작업 범위 결정 조건으로 인덱스를 사용하는 경우
    - 인덱스 컬럼들의 동등 비교 형태
    - 제일 우선되는 인덱스 컬럼을 제외한 나머지 컬럼에 대해 `=`, `IN`, `<`, `>`, `LIKE '%?'`의 경우
    - 
