# Introduction
- 인덱스는 DB 쿼리 성능에 있어서 매우 중요한 역할을 함
  - 쿼리 튜닝의 기본  
- 각 인덱스의 특성과 차이는 상당히 중요함

# 8.1 디스크 읽기 방식 
- CPU, 메모리와 같이 전기적 특성을 띤 장치 성능은 매우 빠른 속도로 발전함  
  - 디스크와 같은 기계식 장치 성능은 제한적으로 발전함
  - SSD가 나왔지만, 여전히 가장 느림 
- DB 성능 튜닝은 디스크 I/O를 어떻게 줄이느냐가 관건일 때가 많음


## 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
### HDD
- 기계식 장치
- DB 서버에서는 디스크 장치가 병목이 됨 

### SSD 
- 기계식 HDD를 대체하기 위해 등장한 전자식 저장 매체 
- SATA, SAS와 같은 인터페이스 지원 → 내장 디스크, DAS, SAN에 그대로 사용 가능 
- HDD의 데이터 저장용 플래터(원판) 제거 → 플래시 메모리 장착 
  - 디스크 원판을 기계적으로 회전시킬 필요 X → 빠른 데이터 입출력 
- D-ram보다는 느리지만 HDD보다는 훨씬 빠름 
- DBMS 서버에는 대부분 SSD를 채택 
- 순차 I/O 
  - 디스크 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 작업  
  - HDD보다 조금 빠르거나 거의 비슷한 성능 
- 랜덤 I/O
  - HDD보다 훨씬 빠름 
  - DB 서버에서는 순차 I/O보다 랜덤 I/O로 작은 데이터를 읽고 쓰는 작업이 대부분임
    - SSD는 DB 서버에 최적화된 디스크 장치임 

## 8.2.2 랜덤 I/O와 순차 I/O
![img.png](img.png)
- 순차 I/O
  - 3개의 페이지를 디스크에 기록하기 위해 1회의 시스템 콜 요청
  - 디스크에 기록해야 할 위치를 찾기 위해 디스크의 헤드를 1회 움직임 
- 랜덤 I/O
  - 3개의 페이지를 디스크에 기록하기 위해 3회의 시스템 콜 요청
  - 디스크에 기록해야 할 위치를 찾기 위해 디스크의 헤드를 3회 움직임
- 즉, 디스크의 성능은 디스크 헤더의 **위치 이동 없이, 얼마나 많은 데이터를 한 번에 기록하느냐**에 의해 결정됨
  - 여러 번 read/write를 요청하는 랜덤 I/O 작업이 부하가 더 큼 
  - DB 서버에서는 랜덤 I/O가 많이 발생함

### RAID controller
- 저장된 데이터에 대한 액세스 속도를 높여 컴퓨팅 성능 향상에 도움을 줄 수 있는 컨트롤러  
  - [참고 자료](https://www.techtarget.com/searchstorage/definition/RAID-controller)
- 기업용 DB 서버에는 일반적으로 캐시 메모리가 장착된 RAID 컨트롤러가 사용됨
  - 캐시 메모리: 빈번한 파일 동기화 작업이 호출되는 순차 I/O를 효율적으로 처리될 수 있게 변환하는 역할 수행
  - 순차 I/O도 파일 동기화 작업이 빈번한 경우, 비효율적인 형태로 처리될 때가 많음 → 이럴 때 RAID controller가 큰 역할을 함

### 쿼리 튜닝
- 랜덤 I/O 자체를 줄여주는 것이 목적 
- 랜덤 I/O를 줄인다 == 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 개선한다 

### 인덱스 레인지 스캔 vs 풀 테이블 스캔 
- 인덱스 레인지 스캔
  - 데이터를 읽기 위해 랜덤 I/O 사용 
- 풀 테이블 스캔
  - 순차 I/O 사용 
  - 큰 테이블의 레코드 대부분을 읽는 작업이나, 테이블에 row가 적은 경우에는 풀 테이블 스캔을 사용하도록 유도할 때가 있음 
    - 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문 
    - 이런 형태는 OLTP(On-Line Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용됨 

---

---

## 8.2 인덱스란?
- 비유 
  - 책 맨 끝의 색인 or 찾아보기 → 인덱스
  - 책의 내용 → 데이터 파일 
- 최대한 빨리 찾을 수 있게 정렬해서 보관함 

### 자료 구조 
- SortedList
  - 인덱스와 같은 자료 구조 
  - 저장되는 값을 항상 정렬된 상태로 유지
  - 저장이 복잡하고 느림 (정렬해야 하므로)
  - 정렬돼 있으므로 빠르게 원하는 값을 찾아올 수 있음
  - DB 서버의 인덱스 또한 DML은 느리나, 조회는 빠름
- ArrayList
  - 데이터 파일과 같은 자료 구조 
  - 저장되는 값을 별도의 정렬 없이 저장되는 순서 그대로 유지

### 인덱스는...
- 데이터 저장(DML) 성능 희생을 희생하고, 데이터 읽기 속도를 높이는 기능이다 
- 인덱스 추가 시 고려 사항
  - 데이터 저장 속도를 어디까지 희생할 수 있는가
  - 읽기 속도를 얼마나 더 빠르게 만들어야 하는가 

    
### 인덱스의 역할 별 분류 
- Primary key
  - record를 대표하는 컬럼의 값으로 만들어진 인덱스 
  - 해당 레코드를 식별할 수 있는 기준값 (식별자)
  - NOT NULL, UNIQUE 제약 조건을 가짐
- Secondary index
  - PK를 제외한 나머지 모든 인덱스 


### 인덱스의 데이터 저장 방식(알고리즘) 별 분류 

|    | B-Tree                                                                                                | Hash                                                                                                        |
|----|-------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| 특징 | - 상당히 오래 전에 도입 & 그만큼 성숙한 알고리즘 <br/> - 컬럼 값 변형 X, 원래 값을 이용해 인덱싱 <br/> - 응용 버전인 R-Tree도 있음(위치 기반 검색 지원) | - 메모리 기반 DB에서 많이 사용 <br/> - 컬럼의 값으로 해시 값을 계산하여 인덱싱(값 변형) <br/> - `Prefix`일치와 같이 값의 일부만 검색하거나 범위 검색 시 사용 불가  |


### 데이터 중복 허용 여부로 분류 
- Unique index
  - PK와 같이 중복된 값을 허용하지 않는 인덱스
  - 옵티마이저에게 상당히 중요한 요소
  - 유니크 인덱스에 대해 `=` 검색 → 항상 1건의 레코드만 읽어오는 것이 보장됨 → 더 찾지 않아도 됨을 옵티마이저에게 알려주는 효과
- Non-unique index
  - 중복된 값을 허용하는 인덱스


---

---

## 8.3 B-Tree 인덱스 









