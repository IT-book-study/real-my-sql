> ### 트랜잭션이란
> - 작업의 완전성을 보장해 주는 것 
>   - 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 하는 것
> - 데이터의 정합성을 보장하기 위한 기능
> 
> ### Lock 이란 
> - 동시성을 제어하기 위한 기능
> 
> ### 격리 수준이란 
> - 하나의 트랜잭션 내에서, 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨 


# 5.1 트랜잭션 
## 5.1.1 MySQL에서의 트랜잭션
- 트랜잭션이란, 하나의 논리적인 작업 셋에 몇 개의 쿼리가 있든지 간에 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것
- 예시 
    ```sql
    -- 조건: InnoDB 스토리지 엔진 사용, autocommit=ON
    -- 테이블에 3이라는 값이 이미 있다고 가정
    insert into table1 (pk) values (1), (2), (3);
    ```
  - 위 쿼리는 실패한다. 3이라는 값이 이미 있기 때문에 `ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'` 라는 에러가 발생한다.
  - InnoDB는 트랜잭션을 지원하기 때문에, 위 쿼리는 아무것도 적용되지 않는다. (insert 문장을 실행하기 전으로 복구)
    - 즉, 테이블에는 3이라는 값만 저장되어 있고, 위 쿼리는 완전히 실패하여 아무것도 적용되지 않는 것이다.
  - InnoDB는 트랜잭션을 지원하여 논리적인 작업셋의 완전한 성공 or 완전한 실패를 보장한다.


- MyISAM, Memory 엔진의 경우 
  - MyISAM은 위 쿼리의 일부가 성공하여 테이블에 1과 2가 저장이 된다. (트랜잭션 지원 X)
  - 이를 일부만 적용되는 현상인 `Partial update`라고 한다. 
    - 이는 데이터의 정합성을 맞추기 어렵게 만드는 요인이 된다.


## 5.1.2 주의사항 
- DB 커넥션과 동일하게, 트랜잭션도 꼭 필요한 최소의 코드에만 적용하자 
- 트랜잭션 범위를 최소화해야 함
- 예시 
  ```text 
  1) 처리 시작 
    => 데이터베이스 커넥션 생성
    => 트랜잭션 시작 
  2) 사용자의 로그인 여부 확인 
  3) 사용자의 글쓰기 내용 오류 여부 확인
  ...대충 많은 작업들을 수행...
  5) 사용자의 입력 내용을 DB에 저장 
  ...대충 많은 작업들을 수행...
  8) 게시물 등록에 대한 알림 메일 발송 
  9) 알림 메일 발송 이력을 DB에 저장
    <= 트랜잭션 종료(COMMIT)
    <= 데이터베이스 커넥션 반납
  10) 처리 완료  
  ```
  - 실제로 DB에 저장하는 작업은 5번부터 시작함 
    - 굳이 1~4번까지의 작업을 트랜잭션으로 묶을 필요가 없음
    - 필요하지 않은 작업도 트랜잭션에 포함시킬 경우, 불필요하게 커넥션 소유 시간이 길어짐
  - 8번 작업과 같이 외부 서버와 통신하는 작업은 DB 트랜잭션 내에서 제거하는 것이 좋음 
    - 외부 서버와 통신할 수 없는 상황이 발생한다면 웹 서버 뿐만 아니라, DB까지 위험해지는 상황이 발생할 것 
  - 트랜잭션 범위가 너무 크면, 별로 중요하지 않은 작업의 오류로 인해 모두가 롤백되어 버릴 수 있다.


- 예시 개선안 
  ```text 
  1) 처리 시작 
  2) 사용자의 로그인 여부 확인 
  3) 사용자의 글쓰기 내용 오류 여부 확인
  4) 첨부로 업로드된 파일 확인 및 저장
    => 데이터베이스 커넥션 생성
    => 트랜잭션 시작 
  5) 사용자의 입력 내용을 DB에 저장
  6) 첨부 파일 정보를 DB에 저장  
    <= 트랜잭션 종료(COMMIT)  
  7) 저장된 내용 또는 기타 정보를 DB에서 조회 
  8) 게시물 등록에 대한 알림 메일 발송 
    => 트랜잭션 시작
  9) 알림 메일 발송 이력을 DB에 저장
    <= 트랜잭션 종료(COMMIT)
    <= 데이터베이스 커넥션 반납
  10) 처리 완료  
  ```
  - 트랜잭션을 단위별로 나누어 트랜잭션 범위를 최소화함
  - 조회 로직은 트랜잭션에서 제외함

- 요약
  - DB 커넥션과 트랜잭션 범위는 최소화 하자
  - 네트워크 작업이 있는 경우(외부 서버와 통신 등)는 반드시 트랜잭션에서 배제하자 

---

--- 

## 5.2 MySQL 엔진의 잠금(Lock)
- MySQL의 Lock
  - 스토리지 엔진 레벨의 락 
    - 스토리지 엔진 간 상호 영향을 미치지 않음 
  - MySQL 엔진 레벨의 락
    - 모든 스토리지 엔진에 영향 
    - 테이블락, 메타데이터 락, 네임드 락 기능 제공 

### 5.2.1 글로벌 락 
- MySQL에서 가장 범위가 큰 락 
  - 한 세션이 글로벌 락 획득 시, 다른 세션에서 `select`를 제외한 대부분의 DDL 이나 DML 문장을 실행하는 경우 대기 상태로 전환됨
- 영향 범위: MySQL 서버 전체
  - 테이블이나 데이터베이스가 달라도 동일하게 영향을 미침 
  - 글로벌락을 거는 동시에 서버에 존재하는 모든 테이블을 닫고 락을 검 
    - 걸기 전에 테이블이나 레코드에 쓰기 락을 거는 SQL이 실행된 경우, 그 작업이 끝날때 까지 기다림
- InnoDB에서는 트랜잭션을 지원하므로, 데이터의 일관된 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없음 
  - 가벼운 글로벌 락의 필요성 -> 백업락 도입
- 백업락 
  - 백업 툴들의 안정적인 실행을 위해 도입된 락
  - 특정 세션이 백업 락을 획득한 경우
    - 불가능한 것 
      - 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보 변경 불가능
      - 데이터베이스 및 테이블 등, 모든 객체 생성 및 변경, 삭제 
      - REPAIR TABLE, OPTIMIZE TABLE 명령 
      - 사용자 관리 및 비밀번호 변경 
    - 가능한 것 
      - 일반적인 테이블의 데이터 변경
  - 정상적으로 복제는 실행되지만, 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시중지함 


### 5.2.2 테이블 락
- 개별 테이블 단위로 설정되는 락 
- 명시적 또는 묵시적으로 획득 가능 
  - 명시적 획득: `LOCK TABLES` 명령어 사용 
    - `UNLOCK TABLES` 명령어로 명시적으로 해제
    - 필요한 상황이 아니면 애플리케이션에서 사용할 일이 거의 없음 
  - 묵시적 획득: MyISAM, Memory 스토리지 엔진에서 데이터 변경 쿼리를 실행하는 경우 발생
    - MySQL 서버가 데이터 변경이 발생하는 동안 테이블 락을 설정하고 데이터를 변경한 후 즉시 락을 해제 

- InnoDB 
  - 스토리지 엔진 차원에서 레코드 기반의 락 제공 
    - 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 발생하지 않음 
  - 테이블 락을 사용하는 경우
    - 스키마를 변경하는 DDL 쿼리의 경우에만 영향을 미침 (DML 쿼리에서는 무시됨)


### 5.2.3 네임드 락 
- 특정 문자열에 대해 락을 설정할 수 있는 기능
  - 대상이 테이블, 레코드, 혹은 `AUTO_INCREMENT`와 같은 데이터베이스 객체가 아니라는 것이 특징
  - 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 락임 
- `GET_LOCK()`, `RELEASE_LOCK()` 함수를 사용하여 획득 및 해제
- 사용 예
  - DB 서버 1대에 5대의 웹 서버가 접속해서 서비스해야 하는 상황에서, 5대의 웹 서버가 어떤 정보에 대해 상호 동기화를 처리해야 할 때 사용하면 쉽게 해결 가능 
  - 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용 가능 
    - 배치 프로그램과 같이 한꺼번에 많은 레코드를 변경하는 쿼리를 사용하는 경우, 데드락의 원인이 되고는 함 
    - 동일 데이터를 참조하거나 변경하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결 가능


### 5.2.4 메타데이터 락 
- 메타데이터: 데이터베이스, 테이블, 뷰, 프로시저, 함수 등의 정보를 저장하는 데이터
- 데이터베이스의 객체(테이블 뷰 등)의 이름이나 구조를 변경할 때 획득하는 락
- 테이블의 이름을 변경하는 경우 자동으로 획득 (`RENAME TABLE` 명령어 사용)
  - `RENAME TABLE`은 원본 이름과 변경될 이름 두 개 모두 한꺼번에 락을 설정함
- 사용 예
  - 배치 프로그램에서 실시간으로 테이블을 바꿔야 하는 요건이 발생하는 경우  
    ```sql
    -- 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성 
    -- 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업 
    -- 새로 만들어진 랭킹 테이블(rank_new)을 서비스용으로 대체하고자 하는 경우 
    rename table rank to rank_backup, rank_new to rank;  -- 모든 이름에 락을 걸어, 중간에 테이블이 존재하지 않는 상황을 방지
    ```
    - 두 개의 rename 작업을 한번에 실행할 경우 `Table not found 'rank`와 같은 상황을 발생시키지 않고 적용 가능  
    - 아래와 같이 나눠서 실행할 경우, `rank` 테이블이 존재하지 않는다는 에러가 발생할 수 있음 
      ```sql
      rename table rank to rank_backup;
      -- 중간에 테이블이 존재하지 않는 순간이 있음 (rank가 rank_backup으로 변경된 후)
      rename table rank_new to rank;
      ```