- 트랜잭션이란 논리적인 작업 셋을 모두 완벽하게 처리하거나 처리되지 못한 경우 작업 전의 상태로 되돌려 작업의 일부만 적용되는 현상을 막는 기능이다.
- 잠금은 동시성을 제어하기 위한 기능이다.
	- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 한 시점에서 한 커넥션만 변경할 수 있게 해준다.
- 격리 수준은 하나의 트랜잭션이나 여러 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨을 의미한다.

# 5.1 트랜잭션
- MyISAM은 트랜잭션을 지원하지않고 InnoDB는 트랜잭션을 지원한다.
## 5.1.1 MySQL에서의 트랜잭션
- 논리적인 작업 셋 자체가 commit 시 100% 적용 또는 rollback시 아무것도 적용되지 않아야한다를 보장해주는 것이다.
- 한 트랜잭션 내 1, 2, 3을 차례로 insert 하다 3에서 오류가 발생해 rollback 이 되었을 때
	- InnoDB 에서는 1, 2, 3의 데이터가 모두 저장되지 않고 원래의 상태로 돌아간다.
	- MyISAM에서는 1, 2의 데이터는 insert 되고, 3의 데이터만 사라진다.
## 5.1.2 주의 사항
- 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 되어있는 범위를 최소화 해야한다.
- 네트워크 작업이 있는 경우 반드시 트랜잭션에서 배제해야 한다.

# 5.2 MySQL 엔진의 잠금
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 영향을 미치지 않는다.

## 5.2.1 글로벌 락
- SELECT 를 제외한 대부분의 DDL 문장이나 DML 문장을 실행할 때 해당 락이 해제 될 때 까지 해당 문장이 대기 상태로 남는다.
- MySQL 서버 전체에 영향을 주며 작업 대상 테이블나 데이터베이스가 다르더라도 동일한 영향을 미친다.
- 글로벌 락 획득 시 백업 시간만큼 락이 진행되어 급한 데이터 처리가 어렵다는 문제가 있어 MySQL 8.0 버전 부터는 백업 락이 도입되었다.
	- 아래의 3가지 정보는 변경할 수 없다.
		- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
		- REPAIR TABLE OPTIMIZE TABLE 명령
		- 사용자 관리 및 비밀번호 변경
	- 하지만 백업락을 획득하면 일반적인 테이블의 데이터 변경이 허용된다.

## 5.2.2 테이블 락
- 테이블 단위로 설정되는 잠금으로 묵시적, 명시적으로 획득할 수 있다.
- 명시적 잠금
	 `LOCK TABLES table_name { READ | WRITE } `로 락을 획득
	 `UNLOCK TABLE` 로 락을 반납한다.
- 묵시적 잠금
	- MyISAM이나 MEMORY 테이블에 데이터 변경 쿼리가 실행하면 자동으로 설정되며 변경이 끝나면 즉시 잠금을 해제한다.
- InnoDB 테이블의 경우 대부분의 DML 쿼리에서는 무시되고, 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

## 5.2.3 네임드 락
- 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.
- 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.
- 사실 어디서 사용하는지 크게 잘 모르겠습니다

## 5.2.4 메타데이터 락
- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금
- 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.


# 5.2 InnoDB 스토리지 엔진 잠금
- MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고있어 뛰어난 동시성 처리를 제공한다.
- MySQL 최근 버전에서는 트랜잭션, 잠금, 잠금 대기중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입되면서 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수 있다.
## 5.3.1 InnoDB 스토리지 엔진의 잠금
- 잠금 정보가 작은 공간으로 관리되어 레코드 락이 페이지 락이나 테이블 락으로 레벨업 되는 경우가 없다.
### 5.3.1.1 레코드 락
- 레코드 자체만을 잠그는 잠금이지만 InnoDB 스토리지 엔진은 인덱스의 레코드를 잠근다
- ❓레코드 자체를 잠그느냐, 아니면 인덱스를 잠그느냐 가 무슨말일까요,,

### 5.3.1.2 갭 락
- 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미하며 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어한다.

### 5.3.1.3 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금

### 5.3.1.4 자동 증가 락
- AUTO_INCREMENT 가 사용되는 경우 적용될 수 있는 잠금
- 동시에 저장되는 레코드가 많은 경우에도 레코드가 중복되지 않고 저장된 순서대로 증가하는 값을 가져야한다.
- AUTO_INCREMENT 락은 아주 짧은 시간에 설정됐다 해제 되기 때문에 대부분의 경우 문제가 발생하지 않는다.
- MySQL 5.0 이후 버전에는 작동 방식을 변경할 수 있게 설정 되었다.
	- `innodb_autoinc_lock_mode=0` : 모든 insert 문장은 자동 증가 락을 사용
	- `innodb_autoinc_lock_mode=1` : insert 되는 레코드의 건수를 정확히 예측할 수 있을 때 사용하며 자동 증가 락이 아닌 래치(뮤텍스)를 이용해 처리한다.
	- `innodb_autoinc_lock_mode=2` : 절대 자동 증가 락을 사용하지 않고 경량화된 래치(뮤텍스)를 이용해 처리해 꼭 순서대로 만들어지기 보다는 유니크한 값이 생성된다를 보장한다.

## 5.3.2 인덱스와 잠금
- InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리되어 변경하는 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야한다.
- 테이블의 인덱스가 하나도 없다면 테이블을 풀 스캔하며 작업을 진행하기 때문에 전체 데이터에 락이 걸리게 된다.
- 따라서 인덱스 설계는 중요하다.

## 5.3.3 레코드 수준의 잠금 확인 및 해제
- MySQL 5.1 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능해졌기 때문에 강제로 잠금을 해제하려면 KILL 명령을 이용해 프로세스를 강제로 종료하면 된다.
- MySQL 8.0 버전부터는 performance_schema의 data_locks 와 data_lock_waits 테이블에서 트랜잭션과 잠금에 대해 조회가 가능하다.

# 5.4 MySQL 의 격리 수준
- `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`의 4가지로 나뉘며 뒤로 갈수록 트랜잭션 간 격리 수준이 높아지면서 동시 처리 성능도 떨어질 수 있다.
- InnoDB 에서는 독특한 특성 때문에 REPEATABLE READ 수준에서도 PHANTOM READ 가 발생하지 않는다.

## 5.4.1 READ UNCOMMITTED
- 더티리드: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- 해당 격리 수준에서는 더티 리드가 허용된다.

## 5.4.2 READ COMMITTED
- 오라클 DBMS 에서 기본적으로 사용되는 격리 수준
- commit 이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- MySQL의 경우 해당 수준 부터 언두로그가 사용되어 이전 데이터를 조회해 보여준다.
- `NON-REPEATABLE READ` 라는 부정합의 문제가 있다.
	- 중간에 한 트랜잭션 처리 중간에 다른 트랜잭션이 변경을 했을 경우 변경된 데이터가 조회된다.

## 5.4.3 REPEATABLE READ
- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- InnoDB 스토리지 엔진은 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업하는데 해당 데이터를 읽어 보여주면서 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
- `READ COMMITTED` 와 `REPEATABLE READ` 의 차이는 언두 영역에 백업된 레코드의 여러버전 가운데 몇 번째 이전 버전까지 찾아 가느냐에 있다.
- 다른 트랜잭션에서 수행한 변경 작업에 의해 **레코드가 추가될 경우** 레코드가 보였다 안보였다 하는 현상이 발생할 수 있다.
	- 레코드가 보였다 안보였다 하는 현상을 `PHANTOM READ` 라고 한다.

## 5.4.4 SERIALIZABLE
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 격리 수준
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 수준에서도 `PHANTOM READ`가 발생하지 않아 해당 수준을 사용할 필요성은 없어 보인다.
